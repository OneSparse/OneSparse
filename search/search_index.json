{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs Matrix","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"Matrix","title":"Welcome to MkDocs"},{"location":"test_matrix_header/","text":"Matrix This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; The 'matrix' data type wraps a SuiteSparse GrB_Matrix handle and delegates functions from SQL to the library through instances of this type. \\dT+ matrix List of data types Schema | Name | Internal name | Size | Elements | Owner | Access privileges | Description -----------+--------+---------------+------+----------+----------+-------------------+------------- onesparse | matrix | matrix | var | | postgres | | (1 row) An empty matrix can be constructed many ways, but one of the simplest is casting a type code to the matrix type. In this case 'i4' means GrB_INT32. The type codes are intentionally compressed to be as short as possible for smaller pg_dumps. select 'i4'::matrix; matrix -------- i4[] (1 row) A matrix can have a fixed number of rows and/or columns. The default possible number of rows and columns is defined by the SuiteSparse library to be GrB_INDEX_MAX which is '2^60' power indexes. For the purposes of this documentation this will be referred to as \"INDEX_MAX\" and matrices and vector dimensions that are INDEX_MAX in size are reffered to as \"unbounded\". For matrices with known dimensions, the dimensions can be provided in parentesis after the type code. Here a 10 row by 10 column matrix is created: select 'i4(10:10)'::matrix; matrix -------- i4[] (1 row) Either dimension can be ommited, this creates a 10 row by unbounded column matrix. select 'i4(10:)'::matrix; matrix -------- i4[] (1 row) This creates a unbounded row by 10 column matrix. select 'i4(10:)'::matrix; matrix -------- i4[] (1 row) Note that in all the above cases the matrices created are empty . They contain no stored elements. The memory needed to hold the matrix contains only stored elements, if there isn't a value stored at a given row or column position, no memory is consumed. This is the \"sparse\" in sparse matrix. This is how it's possible to create an unbounded row by unbounded column matrix without exhausting memory trying to allocate 2^120 entries. All graphblas operations are exposed by a series of functions and operators. Here we see three very common operations, returning the number of rows, the number of columns, and the number of store values. select nrows('i4'::matrix); nrows --------------------- 1152921504606846976 (1 row) select ncols('i4'::matrix); ncols --------------------- 1152921504606846976 (1 row) select nvals('i4'::matrix); nvals ------- 0 (1 row) Above you can see the matrix has unbounded rows and columns (the very large number is the number of possible entries). And the number of stored values is zero. Values can be specified after the 'type(dimension)' prefix as an array of elements between square brackets. Empty brackets imply no elements: select nrows('i4[]'::matrix); nrows --------------------- 1152921504606846976 (1 row) select ncols('i4[]'::matrix); ncols --------------------- 1152921504606846976 (1 row) select nvals('i4[]'::matrix); nvals ------- 0 (1 row) Elements are specified between square brackets are coordinates of 'row_id:column_id:value' separated by spaces: select 'i4[1:1:1 2:2:2 3:3:3]'::matrix; matrix ----------------------- i4[1:1:1 2:2:2 3:3:3] (1 row) select 'i4(10:)[1:1:1 2:2:2 3:3:3]'::matrix; matrix ----------------------- i4[1:1:1 2:2:2 3:3:3] (1 row) select 'i4(:10)[1:1:1 2:2:2 3:3:3]'::matrix; matrix ----------------------- i4[1:1:1 2:2:2 3:3:3] (1 row) Below you see the number of rows, columns and spaces for a variety of combinations: select nrows('i4(10)[1:1:1 2:2:2 3:3:3]'::matrix); nrows ------- 10 (1 row) select ncols('i4(10)[1:1:1 2:2:2 3:3:3]'::matrix); ncols --------------------- 1152921504606846976 (1 row) select nvals('i4(10)[1:1:1 2:2:2 3:3:3]'::matrix); nvals ------- 3 (1 row) select nrows('i4(10:)[1:1:1 2:2:2 3:3:3]'::matrix); nrows ------- 10 (1 row) select ncols('i4(10:)[1:1:1 2:2:2 3:3:3]'::matrix); ncols --------------------- 1152921504606846976 (1 row) select nvals('i4(10:)[1:1:1 2:2:2 3:3:3]'::matrix); nvals ------- 3 (1 row) select nrows('i4(:10)[1:1:1 2:2:2 3:3:3]'::matrix); nrows --------------------- 1152921504606846976 (1 row) select ncols('i4(:10)[1:1:1 2:2:2 3:3:3]'::matrix); ncols ------- 10 (1 row) select nvals('i4(:10)[1:1:1 2:2:2 3:3:3]'::matrix); nvals ------- 3 (1 row) select nrows('i4(10:10)[1:1:1 2:2:2 3:3:3]'::matrix); nrows ------- 10 (1 row) select ncols('i4(10:10)[1:1:1 2:2:2 3:3:3]'::matrix); ncols ------- 10 (1 row) select nvals('i4(10:10)[1:1:1 2:2:2 3:3:3]'::matrix); nvals ------- 3 (1 row) Element-wise operations The GraphBLAS API has elementwise operations on matrices that operate pairs of matrices. 'ewise_add' computes the element-wise \u201caddition\u201d of two matrices A and B, element-wise using any binary operator. Elements present on both sides of the operation are included in the result. select ewise_add('i4[1:1:1 2:2:2 3:3:3]'::matrix, 'i4[1:1:1 2:2:2 3:3:3]'::matrix, 'plus_int32'); ewise_add ----------------------- i4[1:1:2 2:2:4 3:3:6] (1 row) 'ewise_mult' multiplies elements of two matrices, taking only the intersection of common elements in both matrices, if an element is missing from either the left or right side, it is ommited from the result: select ewise_mult('i4[1:1:1 2:2:2 3:3:3]'::matrix, 'i4[1:1:1 2:2:2 3:3:3]'::matrix, 'times_int32'); ewise_mult ----------------------- i4[1:1:1 2:2:4 3:3:9] (1 row) 'ewise_union' is like 'ewise_add' but differs in how the binary op is applied. A pair of scalars, alpha and beta define the inputs to the operator when entries are present in one matrix but not the other. select ewise_union('i4[1:1:1 2:2:2 3:3:3]'::matrix, 42, 'i4[1:1:1 2:2:2 3:3:3]'::matrix, 84, 'plus_int32'); ewise_union ----------------------- i4[1:1:2 2:2:4 3:3:6] (1 row) The entire matrix can be reduced to a scalar value: select reduce_scalar('i4[1:1:1 2:2:2 3:3:3]'::matrix, 'plus_monoid_int32'); reduce_scalar --------------- i4:6 (1 row) The matrix can also be reduced to a column vector: select reduce_vector('i4[1:1:1 1:2:3 2:2:2]'::matrix, 'plus_monoid_int32'); reduce_vector --------------- i4[1:4 2:2] (1 row) To reduce a row vector, specify that the input should be transposed with the descriptor 't0': select reduce_vector('i4[1:1:1 1:2:3 2:2:2]'::matrix, 'plus_monoid_int32', descriptor=>'t0'); reduce_vector --------------- i4[1:1 2:5] (1 row) Matrix Multiplication (referred to here as A @ B) is the heart of linear algebra. All matrix multiplication happens over a semiring. For the most common form of matrix multiplication, the outer opperation is to multiply coresponding elements with the \"times\" operator and then reduce those products with the \"plus\" operator. This is called the \"plus_times\" semiring: select mxm('i4[0:0:1 0:1:2]'::matrix, 'i4[0:0:1 0:1:3]'::matrix, 'plus_times_int32'); mxm ----------------- i4[0:0:1 0:1:3] (1 row) AxB can also be done with the '@' operator, mimicking the Python syntax: select 'i4[0:0:1 0:1:2]'::matrix @ 'i4[0:0:1 0:1:3]'::matrix; ?column? ----------------- i4[0:0:0 0:1:0] (1 row) Matrices can be multipled by vectors on the right taking the linear combination of the matrices columns using the vectors elements as coefficients: select mxv('i4[0:0:1 0:1:2]'::matrix, 'i4[0:0 1:1]'::vector, 'plus_times_int32'); mxv --------- i4[0:2] (1 row) 'mxv' is also supported by the '@' operator: select 'i4[0:0:1 0:1:2]'::matrix @ 'i4[0:0 1:1]'::vector; ?column? ---------- i4[0:0] (1 row) Matrices can be multipled by vectors on the right taking the linear combination of the matrices rows using the vectors elements as coefficients: select vxm('i4[0:0 1:1]'::vector, 'i4[0:0:1 0:1:2]'::matrix, 'plus_times_int32'); vxm ------------- i4[0:0 1:0] (1 row) 'vxm' is also supported by the '@' operator: select 'i4[0:0 1:1]'::vector @ 'i4[0:0:1 0:1:2]'::matrix; ?column? ------------- i4[0:0 1:0] (1 row) The 'selection' method calls the 'GrB_select()' API function. The name 'selection' was chosen not to conflict with the SQL keyword 'select'. Selection provides a conditional operator called an 'indexunaryop' and a parameter for the operator to use to compare elements in the matrix. Below, all elements with values greater than 1 are returned: select selection('i4[1:1:1 2:2:2 3:3:3]'::matrix, 'valuegt_int32'::indexunaryop, 1::scalar); selection ----------------- i4[2:2:2 3:3:3] (1 row) Here are all values equal to 2: select selection('i4[1:1:1 2:2:2 3:3:3]'::matrix, 'valueeq_int32'::indexunaryop, 2::scalar); selection ----------- i4[2:2:2] (1 row) Apply takes an operator called a 'unaryop' and applies it to every element of the matrix. The 'ainv_int32' returned the additive inverse (the negative value for integers) of every element: select apply('i4[1:1:1 2:2:2 3:3:3]'::matrix, 'ainv_int32'::unaryop); apply -------------------------- i4[1:1:-1 2:2:-2 3:3:-3] (1 row) The 'dup' function duplicates a matrix returning a new matrix object with the same values: select dup('i4[1:1:1 2:2:2 3:3:3]'::matrix); dup ----------------------- i4[1:1:1 2:2:2 3:3:3] (1 row) The 'wait' method is used to \"complete\" a matrix, which may have pending operations waiting to be performed when using the default SuiteSparse non-blocking mode. As a side effect, wait will sort the elements of the input: select wait('i4[2:2:2 3:3:3 1:1:1]'::matrix); wait ----------------------- i4[1:1:1 2:2:2 3:3:3] (1 row) The 'clear' function clears the matrix of all elements and returns the same object, but empty. The dimensions do not change: select clear('i4[1:1:1 2:2:2 3:3:3]'::matrix); clear ------- i4[] (1 row)","title":"Matrix"},{"location":"test_matrix_header/#matrix","text":"This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; The 'matrix' data type wraps a SuiteSparse GrB_Matrix handle and delegates functions from SQL to the library through instances of this type. \\dT+ matrix List of data types Schema | Name | Internal name | Size | Elements | Owner | Access privileges | Description -----------+--------+---------------+------+----------+----------+-------------------+------------- onesparse | matrix | matrix | var | | postgres | | (1 row) An empty matrix can be constructed many ways, but one of the simplest is casting a type code to the matrix type. In this case 'i4' means GrB_INT32. The type codes are intentionally compressed to be as short as possible for smaller pg_dumps. select 'i4'::matrix; matrix -------- i4[] (1 row) A matrix can have a fixed number of rows and/or columns. The default possible number of rows and columns is defined by the SuiteSparse library to be GrB_INDEX_MAX which is '2^60' power indexes. For the purposes of this documentation this will be referred to as \"INDEX_MAX\" and matrices and vector dimensions that are INDEX_MAX in size are reffered to as \"unbounded\". For matrices with known dimensions, the dimensions can be provided in parentesis after the type code. Here a 10 row by 10 column matrix is created: select 'i4(10:10)'::matrix; matrix -------- i4[] (1 row) Either dimension can be ommited, this creates a 10 row by unbounded column matrix. select 'i4(10:)'::matrix; matrix -------- i4[] (1 row) This creates a unbounded row by 10 column matrix. select 'i4(10:)'::matrix; matrix -------- i4[] (1 row) Note that in all the above cases the matrices created are empty . They contain no stored elements. The memory needed to hold the matrix contains only stored elements, if there isn't a value stored at a given row or column position, no memory is consumed. This is the \"sparse\" in sparse matrix. This is how it's possible to create an unbounded row by unbounded column matrix without exhausting memory trying to allocate 2^120 entries. All graphblas operations are exposed by a series of functions and operators. Here we see three very common operations, returning the number of rows, the number of columns, and the number of store values. select nrows('i4'::matrix); nrows --------------------- 1152921504606846976 (1 row) select ncols('i4'::matrix); ncols --------------------- 1152921504606846976 (1 row) select nvals('i4'::matrix); nvals ------- 0 (1 row) Above you can see the matrix has unbounded rows and columns (the very large number is the number of possible entries). And the number of stored values is zero. Values can be specified after the 'type(dimension)' prefix as an array of elements between square brackets. Empty brackets imply no elements: select nrows('i4[]'::matrix); nrows --------------------- 1152921504606846976 (1 row) select ncols('i4[]'::matrix); ncols --------------------- 1152921504606846976 (1 row) select nvals('i4[]'::matrix); nvals ------- 0 (1 row) Elements are specified between square brackets are coordinates of 'row_id:column_id:value' separated by spaces: select 'i4[1:1:1 2:2:2 3:3:3]'::matrix; matrix ----------------------- i4[1:1:1 2:2:2 3:3:3] (1 row) select 'i4(10:)[1:1:1 2:2:2 3:3:3]'::matrix; matrix ----------------------- i4[1:1:1 2:2:2 3:3:3] (1 row) select 'i4(:10)[1:1:1 2:2:2 3:3:3]'::matrix; matrix ----------------------- i4[1:1:1 2:2:2 3:3:3] (1 row) Below you see the number of rows, columns and spaces for a variety of combinations: select nrows('i4(10)[1:1:1 2:2:2 3:3:3]'::matrix); nrows ------- 10 (1 row) select ncols('i4(10)[1:1:1 2:2:2 3:3:3]'::matrix); ncols --------------------- 1152921504606846976 (1 row) select nvals('i4(10)[1:1:1 2:2:2 3:3:3]'::matrix); nvals ------- 3 (1 row) select nrows('i4(10:)[1:1:1 2:2:2 3:3:3]'::matrix); nrows ------- 10 (1 row) select ncols('i4(10:)[1:1:1 2:2:2 3:3:3]'::matrix); ncols --------------------- 1152921504606846976 (1 row) select nvals('i4(10:)[1:1:1 2:2:2 3:3:3]'::matrix); nvals ------- 3 (1 row) select nrows('i4(:10)[1:1:1 2:2:2 3:3:3]'::matrix); nrows --------------------- 1152921504606846976 (1 row) select ncols('i4(:10)[1:1:1 2:2:2 3:3:3]'::matrix); ncols ------- 10 (1 row) select nvals('i4(:10)[1:1:1 2:2:2 3:3:3]'::matrix); nvals ------- 3 (1 row) select nrows('i4(10:10)[1:1:1 2:2:2 3:3:3]'::matrix); nrows ------- 10 (1 row) select ncols('i4(10:10)[1:1:1 2:2:2 3:3:3]'::matrix); ncols ------- 10 (1 row) select nvals('i4(10:10)[1:1:1 2:2:2 3:3:3]'::matrix); nvals ------- 3 (1 row)","title":"Matrix"},{"location":"test_matrix_header/#element-wise-operations","text":"The GraphBLAS API has elementwise operations on matrices that operate pairs of matrices. 'ewise_add' computes the element-wise \u201caddition\u201d of two matrices A and B, element-wise using any binary operator. Elements present on both sides of the operation are included in the result. select ewise_add('i4[1:1:1 2:2:2 3:3:3]'::matrix, 'i4[1:1:1 2:2:2 3:3:3]'::matrix, 'plus_int32'); ewise_add ----------------------- i4[1:1:2 2:2:4 3:3:6] (1 row) 'ewise_mult' multiplies elements of two matrices, taking only the intersection of common elements in both matrices, if an element is missing from either the left or right side, it is ommited from the result: select ewise_mult('i4[1:1:1 2:2:2 3:3:3]'::matrix, 'i4[1:1:1 2:2:2 3:3:3]'::matrix, 'times_int32'); ewise_mult ----------------------- i4[1:1:1 2:2:4 3:3:9] (1 row) 'ewise_union' is like 'ewise_add' but differs in how the binary op is applied. A pair of scalars, alpha and beta define the inputs to the operator when entries are present in one matrix but not the other. select ewise_union('i4[1:1:1 2:2:2 3:3:3]'::matrix, 42, 'i4[1:1:1 2:2:2 3:3:3]'::matrix, 84, 'plus_int32'); ewise_union ----------------------- i4[1:1:2 2:2:4 3:3:6] (1 row) The entire matrix can be reduced to a scalar value: select reduce_scalar('i4[1:1:1 2:2:2 3:3:3]'::matrix, 'plus_monoid_int32'); reduce_scalar --------------- i4:6 (1 row) The matrix can also be reduced to a column vector: select reduce_vector('i4[1:1:1 1:2:3 2:2:2]'::matrix, 'plus_monoid_int32'); reduce_vector --------------- i4[1:4 2:2] (1 row) To reduce a row vector, specify that the input should be transposed with the descriptor 't0': select reduce_vector('i4[1:1:1 1:2:3 2:2:2]'::matrix, 'plus_monoid_int32', descriptor=>'t0'); reduce_vector --------------- i4[1:1 2:5] (1 row) Matrix Multiplication (referred to here as A @ B) is the heart of linear algebra. All matrix multiplication happens over a semiring. For the most common form of matrix multiplication, the outer opperation is to multiply coresponding elements with the \"times\" operator and then reduce those products with the \"plus\" operator. This is called the \"plus_times\" semiring: select mxm('i4[0:0:1 0:1:2]'::matrix, 'i4[0:0:1 0:1:3]'::matrix, 'plus_times_int32'); mxm ----------------- i4[0:0:1 0:1:3] (1 row) AxB can also be done with the '@' operator, mimicking the Python syntax: select 'i4[0:0:1 0:1:2]'::matrix @ 'i4[0:0:1 0:1:3]'::matrix; ?column? ----------------- i4[0:0:0 0:1:0] (1 row) Matrices can be multipled by vectors on the right taking the linear combination of the matrices columns using the vectors elements as coefficients: select mxv('i4[0:0:1 0:1:2]'::matrix, 'i4[0:0 1:1]'::vector, 'plus_times_int32'); mxv --------- i4[0:2] (1 row) 'mxv' is also supported by the '@' operator: select 'i4[0:0:1 0:1:2]'::matrix @ 'i4[0:0 1:1]'::vector; ?column? ---------- i4[0:0] (1 row) Matrices can be multipled by vectors on the right taking the linear combination of the matrices rows using the vectors elements as coefficients: select vxm('i4[0:0 1:1]'::vector, 'i4[0:0:1 0:1:2]'::matrix, 'plus_times_int32'); vxm ------------- i4[0:0 1:0] (1 row) 'vxm' is also supported by the '@' operator: select 'i4[0:0 1:1]'::vector @ 'i4[0:0:1 0:1:2]'::matrix; ?column? ------------- i4[0:0 1:0] (1 row) The 'selection' method calls the 'GrB_select()' API function. The name 'selection' was chosen not to conflict with the SQL keyword 'select'. Selection provides a conditional operator called an 'indexunaryop' and a parameter for the operator to use to compare elements in the matrix. Below, all elements with values greater than 1 are returned: select selection('i4[1:1:1 2:2:2 3:3:3]'::matrix, 'valuegt_int32'::indexunaryop, 1::scalar); selection ----------------- i4[2:2:2 3:3:3] (1 row) Here are all values equal to 2: select selection('i4[1:1:1 2:2:2 3:3:3]'::matrix, 'valueeq_int32'::indexunaryop, 2::scalar); selection ----------- i4[2:2:2] (1 row) Apply takes an operator called a 'unaryop' and applies it to every element of the matrix. The 'ainv_int32' returned the additive inverse (the negative value for integers) of every element: select apply('i4[1:1:1 2:2:2 3:3:3]'::matrix, 'ainv_int32'::unaryop); apply -------------------------- i4[1:1:-1 2:2:-2 3:3:-3] (1 row) The 'dup' function duplicates a matrix returning a new matrix object with the same values: select dup('i4[1:1:1 2:2:2 3:3:3]'::matrix); dup ----------------------- i4[1:1:1 2:2:2 3:3:3] (1 row) The 'wait' method is used to \"complete\" a matrix, which may have pending operations waiting to be performed when using the default SuiteSparse non-blocking mode. As a side effect, wait will sort the elements of the input: select wait('i4[2:2:2 3:3:3 1:1:1]'::matrix); wait ----------------------- i4[1:1:1 2:2:2 3:3:3] (1 row) The 'clear' function clears the matrix of all elements and returns the same object, but empty. The dimensions do not change: select clear('i4[1:1:1 2:2:2 3:3:3]'::matrix); clear ------- i4[] (1 row)","title":"Element-wise operations"},{"location":"test_scalar_cast_b/","text":"Scalar 'bool' Casting This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; These casting functions cast the Postgres type bool to the GraphBLAS scalar type GrB_BOOL. select cast(0::bool as scalar); scalar -------- b:f (1 row) select cast(0::bool as scalar); scalar -------- b:f (1 row) select cast(1::bool as scalar); scalar -------- b:t (1 row) These tests cast back from the scalar type GrB_BOOL to the Postgres type bool select cast(0::bool::scalar as bool); bool ------ f (1 row) select cast(0::bool::scalar as bool); bool ------ f (1 row) select cast(1::bool::scalar as scalar); scalar -------- b:t (1 row)","title":"Scalar 'bool' Casting"},{"location":"test_scalar_cast_b/#scalar-bool-casting","text":"This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; These casting functions cast the Postgres type bool to the GraphBLAS scalar type GrB_BOOL. select cast(0::bool as scalar); scalar -------- b:f (1 row) select cast(0::bool as scalar); scalar -------- b:f (1 row) select cast(1::bool as scalar); scalar -------- b:t (1 row) These tests cast back from the scalar type GrB_BOOL to the Postgres type bool select cast(0::bool::scalar as bool); bool ------ f (1 row) select cast(0::bool::scalar as bool); bool ------ f (1 row) select cast(1::bool::scalar as scalar); scalar -------- b:t (1 row)","title":"Scalar 'bool' Casting"},{"location":"test_scalar_cast_f4/","text":"Scalar 'float4' Casting This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; These casting functions cast the Postgres type float4 to the GraphBLAS scalar type GrB_INT32. select cast(-1::float4 as scalar); scalar -------------- f4:-1.000000 (1 row) select cast(0::float4 as scalar); scalar ------------- f4:0.000000 (1 row) select cast(1::float4 as scalar); scalar ------------- f4:1.000000 (1 row) These tests cast back from the scalar type GrB_INT32 to the Postgres type float4 select cast(-1::float4::scalar as float4); ERROR: operator does not exist: - scalar LINE 1: select cast(-1::float4::scalar as float4); ^ HINT: No operator matches the given name and argument type. You might need to add an explicit type cast. select cast(0::float4::scalar as float4); float4 -------- 0 (1 row) select cast(1::float4::scalar as scalar); scalar ------------- f4:1.000000 (1 row)","title":"Scalar 'float4' Casting"},{"location":"test_scalar_cast_f4/#scalar-float4-casting","text":"This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; These casting functions cast the Postgres type float4 to the GraphBLAS scalar type GrB_INT32. select cast(-1::float4 as scalar); scalar -------------- f4:-1.000000 (1 row) select cast(0::float4 as scalar); scalar ------------- f4:0.000000 (1 row) select cast(1::float4 as scalar); scalar ------------- f4:1.000000 (1 row) These tests cast back from the scalar type GrB_INT32 to the Postgres type float4 select cast(-1::float4::scalar as float4); ERROR: operator does not exist: - scalar LINE 1: select cast(-1::float4::scalar as float4); ^ HINT: No operator matches the given name and argument type. You might need to add an explicit type cast. select cast(0::float4::scalar as float4); float4 -------- 0 (1 row) select cast(1::float4::scalar as scalar); scalar ------------- f4:1.000000 (1 row)","title":"Scalar 'float4' Casting"},{"location":"test_scalar_cast_f8/","text":"Scalar 'float8' Casting This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; These casting functions cast the Postgres type float8 to the GraphBLAS scalar type GrB_INT64. select cast(-1::float8 as scalar); scalar -------------- f8:-1.000000 (1 row) select cast(0::float8 as scalar); scalar ------------- f8:0.000000 (1 row) select cast(1::float8 as scalar); scalar ------------- f8:1.000000 (1 row) These tests cast back from the scalar type GrB_INT64 to the Postgres type float8 select cast(-1::float8::scalar as float8); ERROR: operator does not exist: - scalar LINE 1: select cast(-1::float8::scalar as float8); ^ HINT: No operator matches the given name and argument type. You might need to add an explicit type cast. select cast(0::float8::scalar as float8); float8 -------- 0 (1 row) select cast(1::float8::scalar as scalar); scalar ------------- f8:1.000000 (1 row)","title":"Scalar 'float8' Casting"},{"location":"test_scalar_cast_f8/#scalar-float8-casting","text":"This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; These casting functions cast the Postgres type float8 to the GraphBLAS scalar type GrB_INT64. select cast(-1::float8 as scalar); scalar -------------- f8:-1.000000 (1 row) select cast(0::float8 as scalar); scalar ------------- f8:0.000000 (1 row) select cast(1::float8 as scalar); scalar ------------- f8:1.000000 (1 row) These tests cast back from the scalar type GrB_INT64 to the Postgres type float8 select cast(-1::float8::scalar as float8); ERROR: operator does not exist: - scalar LINE 1: select cast(-1::float8::scalar as float8); ^ HINT: No operator matches the given name and argument type. You might need to add an explicit type cast. select cast(0::float8::scalar as float8); float8 -------- 0 (1 row) select cast(1::float8::scalar as scalar); scalar ------------- f8:1.000000 (1 row)","title":"Scalar 'float8' Casting"},{"location":"test_scalar_cast_i2/","text":"Scalar 'smallint' Casting This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; These casting functions cast the Postgres type smallint to the GraphBLAS scalar type GrB_INT16. select cast(-1::smallint as scalar); scalar -------- i2:-1 (1 row) select cast(0::smallint as scalar); scalar -------- i2:0 (1 row) select cast(1::smallint as scalar); scalar -------- i2:1 (1 row) These tests cast back from the scalar type GrB_INT16 to the Postgres type smallint select cast(-1::smallint::scalar as smallint); ERROR: operator does not exist: - scalar LINE 1: select cast(-1::smallint::scalar as smallint); ^ HINT: No operator matches the given name and argument type. You might need to add an explicit type cast. select cast(0::smallint::scalar as smallint); int2 ------ 0 (1 row) select cast(1::smallint::scalar as scalar); scalar -------- i2:1 (1 row)","title":"Scalar 'smallint' Casting"},{"location":"test_scalar_cast_i2/#scalar-smallint-casting","text":"This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; These casting functions cast the Postgres type smallint to the GraphBLAS scalar type GrB_INT16. select cast(-1::smallint as scalar); scalar -------- i2:-1 (1 row) select cast(0::smallint as scalar); scalar -------- i2:0 (1 row) select cast(1::smallint as scalar); scalar -------- i2:1 (1 row) These tests cast back from the scalar type GrB_INT16 to the Postgres type smallint select cast(-1::smallint::scalar as smallint); ERROR: operator does not exist: - scalar LINE 1: select cast(-1::smallint::scalar as smallint); ^ HINT: No operator matches the given name and argument type. You might need to add an explicit type cast. select cast(0::smallint::scalar as smallint); int2 ------ 0 (1 row) select cast(1::smallint::scalar as scalar); scalar -------- i2:1 (1 row)","title":"Scalar 'smallint' Casting"},{"location":"test_scalar_cast_i4/","text":"Scalar 'integer' Casting This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; These casting functions cast the Postgres type integer to the GraphBLAS scalar type GrB_INT32. select cast(-1::integer as scalar); scalar -------- i4:-1 (1 row) select cast(0::integer as scalar); scalar -------- i4:0 (1 row) select cast(1::integer as scalar); scalar -------- i4:1 (1 row) These tests cast back from the scalar type GrB_INT32 to the Postgres type integer select cast(-1::integer::scalar as integer); ERROR: operator does not exist: - scalar LINE 1: select cast(-1::integer::scalar as integer); ^ HINT: No operator matches the given name and argument type. You might need to add an explicit type cast. select cast(0::integer::scalar as integer); int4 ------ 0 (1 row) select cast(1::integer::scalar as scalar); scalar -------- i4:1 (1 row)","title":"Scalar 'integer' Casting"},{"location":"test_scalar_cast_i4/#scalar-integer-casting","text":"This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; These casting functions cast the Postgres type integer to the GraphBLAS scalar type GrB_INT32. select cast(-1::integer as scalar); scalar -------- i4:-1 (1 row) select cast(0::integer as scalar); scalar -------- i4:0 (1 row) select cast(1::integer as scalar); scalar -------- i4:1 (1 row) These tests cast back from the scalar type GrB_INT32 to the Postgres type integer select cast(-1::integer::scalar as integer); ERROR: operator does not exist: - scalar LINE 1: select cast(-1::integer::scalar as integer); ^ HINT: No operator matches the given name and argument type. You might need to add an explicit type cast. select cast(0::integer::scalar as integer); int4 ------ 0 (1 row) select cast(1::integer::scalar as scalar); scalar -------- i4:1 (1 row)","title":"Scalar 'integer' Casting"},{"location":"test_scalar_cast_i8/","text":"Scalar 'bigint' Casting This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; These casting functions cast the Postgres type bigint to the GraphBLAS scalar type GrB_INT64. select cast(-1::bigint as scalar); scalar -------- i8:-1 (1 row) select cast(0::bigint as scalar); scalar -------- i8:0 (1 row) select cast(1::bigint as scalar); scalar -------- i8:1 (1 row) These tests cast back from the scalar type GrB_INT64 to the Postgres type bigint select cast(-1::bigint::scalar as bigint); ERROR: operator does not exist: - scalar LINE 1: select cast(-1::bigint::scalar as bigint); ^ HINT: No operator matches the given name and argument type. You might need to add an explicit type cast. select cast(0::bigint::scalar as bigint); int8 ------ 0 (1 row) select cast(1::bigint::scalar as scalar); scalar -------- i8:1 (1 row)","title":"Scalar 'bigint' Casting"},{"location":"test_scalar_cast_i8/#scalar-bigint-casting","text":"This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; These casting functions cast the Postgres type bigint to the GraphBLAS scalar type GrB_INT64. select cast(-1::bigint as scalar); scalar -------- i8:-1 (1 row) select cast(0::bigint as scalar); scalar -------- i8:0 (1 row) select cast(1::bigint as scalar); scalar -------- i8:1 (1 row) These tests cast back from the scalar type GrB_INT64 to the Postgres type bigint select cast(-1::bigint::scalar as bigint); ERROR: operator does not exist: - scalar LINE 1: select cast(-1::bigint::scalar as bigint); ^ HINT: No operator matches the given name and argument type. You might need to add an explicit type cast. select cast(0::bigint::scalar as bigint); int8 ------ 0 (1 row) select cast(1::bigint::scalar as scalar); scalar -------- i8:1 (1 row)","title":"Scalar 'bigint' Casting"},{"location":"test_scalar_func_b/","text":"Scalar 'bool' Functions This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; Test construction of min, zero and max values: select '0'::bool::scalar; scalar -------- b:f (1 row) select '0'::bool::scalar; scalar -------- b:f (1 row) select '1'::bool::scalar; scalar -------- b:t (1 row) Test setting a scalar value from max to 2 select set('1'::bool::scalar, 2); set ----- b:t (1 row) Test various casting functions used by the CREATE CAST machinery: select scalar_bool((0)::bool); scalar_bool ------------- b:f (1 row) select scalar_bool((0)::bool); scalar_bool ------------- b:f (1 row) select scalar_bool((1)::bool); scalar_bool ------------- b:t (1 row) select bool_scalar((0)::bool::scalar); bool_scalar ------------- f (1 row) select bool_scalar((0)::bool::scalar); bool_scalar ------------- f (1 row) select bool_scalar((1)::bool::scalar); bool_scalar ------------- t (1 row)","title":"Scalar 'bool' Functions"},{"location":"test_scalar_func_b/#scalar-bool-functions","text":"This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; Test construction of min, zero and max values: select '0'::bool::scalar; scalar -------- b:f (1 row) select '0'::bool::scalar; scalar -------- b:f (1 row) select '1'::bool::scalar; scalar -------- b:t (1 row) Test setting a scalar value from max to 2 select set('1'::bool::scalar, 2); set ----- b:t (1 row) Test various casting functions used by the CREATE CAST machinery: select scalar_bool((0)::bool); scalar_bool ------------- b:f (1 row) select scalar_bool((0)::bool); scalar_bool ------------- b:f (1 row) select scalar_bool((1)::bool); scalar_bool ------------- b:t (1 row) select bool_scalar((0)::bool::scalar); bool_scalar ------------- f (1 row) select bool_scalar((0)::bool::scalar); bool_scalar ------------- f (1 row) select bool_scalar((1)::bool::scalar); bool_scalar ------------- t (1 row)","title":"Scalar 'bool' Functions"},{"location":"test_scalar_func_f4/","text":"Scalar 'float4' Functions This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; Test construction of min, zero and max values: select '-1'::float4::scalar; scalar -------------- f4:-1.000000 (1 row) select '0'::float4::scalar; scalar ------------- f4:0.000000 (1 row) select '1'::float4::scalar; scalar ------------- f4:1.000000 (1 row) Test setting a scalar value from max to 2 select set('1'::float4::scalar, 2); set ------------- f4:2.000000 (1 row) Test various casting functions used by the CREATE CAST machinery: select scalar_float4((-1)::float4); scalar_float4 --------------- f4:-1.000000 (1 row) select scalar_float4((0)::float4); scalar_float4 --------------- f4:0.000000 (1 row) select scalar_float4((1)::float4); scalar_float4 --------------- f4:1.000000 (1 row) select float4_scalar((-1)::float4::scalar); float4_scalar --------------- -1 (1 row) select float4_scalar((0)::float4::scalar); float4_scalar --------------- 0 (1 row) select float4_scalar((1)::float4::scalar); float4_scalar --------------- 1 (1 row)","title":"Scalar 'float4' Functions"},{"location":"test_scalar_func_f4/#scalar-float4-functions","text":"This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; Test construction of min, zero and max values: select '-1'::float4::scalar; scalar -------------- f4:-1.000000 (1 row) select '0'::float4::scalar; scalar ------------- f4:0.000000 (1 row) select '1'::float4::scalar; scalar ------------- f4:1.000000 (1 row) Test setting a scalar value from max to 2 select set('1'::float4::scalar, 2); set ------------- f4:2.000000 (1 row) Test various casting functions used by the CREATE CAST machinery: select scalar_float4((-1)::float4); scalar_float4 --------------- f4:-1.000000 (1 row) select scalar_float4((0)::float4); scalar_float4 --------------- f4:0.000000 (1 row) select scalar_float4((1)::float4); scalar_float4 --------------- f4:1.000000 (1 row) select float4_scalar((-1)::float4::scalar); float4_scalar --------------- -1 (1 row) select float4_scalar((0)::float4::scalar); float4_scalar --------------- 0 (1 row) select float4_scalar((1)::float4::scalar); float4_scalar --------------- 1 (1 row)","title":"Scalar 'float4' Functions"},{"location":"test_scalar_func_f8/","text":"Scalar 'float8' Functions This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; Test construction of min, zero and max values: select '-1'::float8::scalar; scalar -------------- f8:-1.000000 (1 row) select '0'::float8::scalar; scalar ------------- f8:0.000000 (1 row) select '1'::float8::scalar; scalar ------------- f8:1.000000 (1 row) Test setting a scalar value from max to 2 select set('1'::float8::scalar, 2); set ------------- f8:2.000000 (1 row) Test various casting functions used by the CREATE CAST machinery: select scalar_float8((-1)::float8); scalar_float8 --------------- f8:-1.000000 (1 row) select scalar_float8((0)::float8); scalar_float8 --------------- f8:0.000000 (1 row) select scalar_float8((1)::float8); scalar_float8 --------------- f8:1.000000 (1 row) select float8_scalar((-1)::float8::scalar); float8_scalar --------------- -1 (1 row) select float8_scalar((0)::float8::scalar); float8_scalar --------------- 0 (1 row) select float8_scalar((1)::float8::scalar); float8_scalar --------------- 1 (1 row)","title":"Scalar 'float8' Functions"},{"location":"test_scalar_func_f8/#scalar-float8-functions","text":"This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; Test construction of min, zero and max values: select '-1'::float8::scalar; scalar -------------- f8:-1.000000 (1 row) select '0'::float8::scalar; scalar ------------- f8:0.000000 (1 row) select '1'::float8::scalar; scalar ------------- f8:1.000000 (1 row) Test setting a scalar value from max to 2 select set('1'::float8::scalar, 2); set ------------- f8:2.000000 (1 row) Test various casting functions used by the CREATE CAST machinery: select scalar_float8((-1)::float8); scalar_float8 --------------- f8:-1.000000 (1 row) select scalar_float8((0)::float8); scalar_float8 --------------- f8:0.000000 (1 row) select scalar_float8((1)::float8); scalar_float8 --------------- f8:1.000000 (1 row) select float8_scalar((-1)::float8::scalar); float8_scalar --------------- -1 (1 row) select float8_scalar((0)::float8::scalar); float8_scalar --------------- 0 (1 row) select float8_scalar((1)::float8::scalar); float8_scalar --------------- 1 (1 row)","title":"Scalar 'float8' Functions"},{"location":"test_scalar_func_i2/","text":"Scalar 'smallint' Functions This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; Test construction of min, zero and max values: select '-1'::smallint::scalar; scalar -------- i2:-1 (1 row) select '0'::smallint::scalar; scalar -------- i2:0 (1 row) select '1'::smallint::scalar; scalar -------- i2:1 (1 row) Test setting a scalar value from max to 2 select set('1'::smallint::scalar, 2); set ------ i2:2 (1 row) Test various casting functions used by the CREATE CAST machinery: select scalar_smallint((-1)::smallint); scalar_smallint ----------------- i2:-1 (1 row) select scalar_smallint((0)::smallint); scalar_smallint ----------------- i2:0 (1 row) select scalar_smallint((1)::smallint); scalar_smallint ----------------- i2:1 (1 row) select smallint_scalar((-1)::smallint::scalar); smallint_scalar ----------------- -1 (1 row) select smallint_scalar((0)::smallint::scalar); smallint_scalar ----------------- 0 (1 row) select smallint_scalar((1)::smallint::scalar); smallint_scalar ----------------- 1 (1 row)","title":"Scalar 'smallint' Functions"},{"location":"test_scalar_func_i2/#scalar-smallint-functions","text":"This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; Test construction of min, zero and max values: select '-1'::smallint::scalar; scalar -------- i2:-1 (1 row) select '0'::smallint::scalar; scalar -------- i2:0 (1 row) select '1'::smallint::scalar; scalar -------- i2:1 (1 row) Test setting a scalar value from max to 2 select set('1'::smallint::scalar, 2); set ------ i2:2 (1 row) Test various casting functions used by the CREATE CAST machinery: select scalar_smallint((-1)::smallint); scalar_smallint ----------------- i2:-1 (1 row) select scalar_smallint((0)::smallint); scalar_smallint ----------------- i2:0 (1 row) select scalar_smallint((1)::smallint); scalar_smallint ----------------- i2:1 (1 row) select smallint_scalar((-1)::smallint::scalar); smallint_scalar ----------------- -1 (1 row) select smallint_scalar((0)::smallint::scalar); smallint_scalar ----------------- 0 (1 row) select smallint_scalar((1)::smallint::scalar); smallint_scalar ----------------- 1 (1 row)","title":"Scalar 'smallint' Functions"},{"location":"test_scalar_func_i4/","text":"Scalar 'integer' Functions This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; Test construction of min, zero and max values: select '-1'::integer::scalar; scalar -------- i4:-1 (1 row) select '0'::integer::scalar; scalar -------- i4:0 (1 row) select '1'::integer::scalar; scalar -------- i4:1 (1 row) Test setting a scalar value from max to 2 select set('1'::integer::scalar, 2); set ------ i4:2 (1 row) Test various casting functions used by the CREATE CAST machinery: select scalar_integer((-1)::integer); scalar_integer ---------------- i4:-1 (1 row) select scalar_integer((0)::integer); scalar_integer ---------------- i4:0 (1 row) select scalar_integer((1)::integer); scalar_integer ---------------- i4:1 (1 row) select integer_scalar((-1)::integer::scalar); integer_scalar ---------------- -1 (1 row) select integer_scalar((0)::integer::scalar); integer_scalar ---------------- 0 (1 row) select integer_scalar((1)::integer::scalar); integer_scalar ---------------- 1 (1 row)","title":"Scalar 'integer' Functions"},{"location":"test_scalar_func_i4/#scalar-integer-functions","text":"This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; Test construction of min, zero and max values: select '-1'::integer::scalar; scalar -------- i4:-1 (1 row) select '0'::integer::scalar; scalar -------- i4:0 (1 row) select '1'::integer::scalar; scalar -------- i4:1 (1 row) Test setting a scalar value from max to 2 select set('1'::integer::scalar, 2); set ------ i4:2 (1 row) Test various casting functions used by the CREATE CAST machinery: select scalar_integer((-1)::integer); scalar_integer ---------------- i4:-1 (1 row) select scalar_integer((0)::integer); scalar_integer ---------------- i4:0 (1 row) select scalar_integer((1)::integer); scalar_integer ---------------- i4:1 (1 row) select integer_scalar((-1)::integer::scalar); integer_scalar ---------------- -1 (1 row) select integer_scalar((0)::integer::scalar); integer_scalar ---------------- 0 (1 row) select integer_scalar((1)::integer::scalar); integer_scalar ---------------- 1 (1 row)","title":"Scalar 'integer' Functions"},{"location":"test_scalar_func_i8/","text":"Scalar 'bigint' Functions This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; Test construction of min, zero and max values: select '-1'::bigint::scalar; scalar -------- i8:-1 (1 row) select '0'::bigint::scalar; scalar -------- i8:0 (1 row) select '1'::bigint::scalar; scalar -------- i8:1 (1 row) Test setting a scalar value from max to 2 select set('1'::bigint::scalar, 2); set ------ i8:2 (1 row) Test various casting functions used by the CREATE CAST machinery: select scalar_bigint((-1)::bigint); scalar_bigint --------------- i8:-1 (1 row) select scalar_bigint((0)::bigint); scalar_bigint --------------- i8:0 (1 row) select scalar_bigint((1)::bigint); scalar_bigint --------------- i8:1 (1 row) select bigint_scalar((-1)::bigint::scalar); bigint_scalar --------------- -1 (1 row) select bigint_scalar((0)::bigint::scalar); bigint_scalar --------------- 0 (1 row) select bigint_scalar((1)::bigint::scalar); bigint_scalar --------------- 1 (1 row)","title":"Scalar 'bigint' Functions"},{"location":"test_scalar_func_i8/#scalar-bigint-functions","text":"This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; Test construction of min, zero and max values: select '-1'::bigint::scalar; scalar -------- i8:-1 (1 row) select '0'::bigint::scalar; scalar -------- i8:0 (1 row) select '1'::bigint::scalar; scalar -------- i8:1 (1 row) Test setting a scalar value from max to 2 select set('1'::bigint::scalar, 2); set ------ i8:2 (1 row) Test various casting functions used by the CREATE CAST machinery: select scalar_bigint((-1)::bigint); scalar_bigint --------------- i8:-1 (1 row) select scalar_bigint((0)::bigint); scalar_bigint --------------- i8:0 (1 row) select scalar_bigint((1)::bigint); scalar_bigint --------------- i8:1 (1 row) select bigint_scalar((-1)::bigint::scalar); bigint_scalar --------------- -1 (1 row) select bigint_scalar((0)::bigint::scalar); bigint_scalar --------------- 0 (1 row) select bigint_scalar((1)::bigint::scalar); bigint_scalar --------------- 1 (1 row)","title":"Scalar 'bigint' Functions"},{"location":"test_scalar_header/","text":"Scalar This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; Describe the scalar type \\dT+ scalar List of data types Schema | Name | Internal name | Size | Elements | Owner | Access privileges | Description -----------+--------+---------------+------+----------+----------+-------------------+------------- onesparse | scalar | scalar | var | | postgres | | (1 row) Duplicate a scalar select dup('i4:42'::scalar); dup ------- i4:42 (1 row) Wait for a scalar to complete in non-blocking mode select wait('i4:42'::scalar); wait ------- i4:42 (1 row) Clear a scalar, deleting its stored element. select clear('i4:42'::scalar); clear ------- i4: (1 row)","title":"Scalar"},{"location":"test_scalar_header/#scalar","text":"This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; Describe the scalar type \\dT+ scalar List of data types Schema | Name | Internal name | Size | Elements | Owner | Access privileges | Description -----------+--------+---------------+------+----------+----------+-------------------+------------- onesparse | scalar | scalar | var | | postgres | | (1 row) Duplicate a scalar select dup('i4:42'::scalar); dup ------- i4:42 (1 row) Wait for a scalar to complete in non-blocking mode select wait('i4:42'::scalar); wait ------- i4:42 (1 row) Clear a scalar, deleting its stored element. select clear('i4:42'::scalar); clear ------- i4: (1 row)","title":"Scalar"},{"location":"test_scalar_math_f4/","text":"Scalar 'float4' Math This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; Add mixed scalar objects and postgres scalar values select (-1::float4)::scalar + 1::float4; ?column? ------------- f4:0.000000 (1 row) select -1::float4 + (1::float4)::scalar; ?column? ---------- 0 (1 row)","title":"Scalar 'float4' Math"},{"location":"test_scalar_math_f4/#scalar-float4-math","text":"This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; Add mixed scalar objects and postgres scalar values select (-1::float4)::scalar + 1::float4; ?column? ------------- f4:0.000000 (1 row) select -1::float4 + (1::float4)::scalar; ?column? ---------- 0 (1 row)","title":"Scalar 'float4' Math"},{"location":"test_scalar_math_f8/","text":"Scalar 'float8' Math This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; Add mixed scalar objects and postgres scalar values select (-1::float8)::scalar + 1::float8; ?column? ------------- f8:0.000000 (1 row) select -1::float8 + (1::float8)::scalar; ?column? ---------- 0 (1 row)","title":"Scalar 'float8' Math"},{"location":"test_scalar_math_f8/#scalar-float8-math","text":"This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; Add mixed scalar objects and postgres scalar values select (-1::float8)::scalar + 1::float8; ?column? ------------- f8:0.000000 (1 row) select -1::float8 + (1::float8)::scalar; ?column? ---------- 0 (1 row)","title":"Scalar 'float8' Math"},{"location":"test_scalar_math_i2/","text":"Scalar 'smallint' Math This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; Add mixed scalar objects and postgres scalar values select (-1::smallint)::scalar + 1::smallint; ?column? ---------- i2:0 (1 row) select -1::smallint + (1::smallint)::scalar; ?column? ---------- 0 (1 row)","title":"Scalar 'smallint' Math"},{"location":"test_scalar_math_i2/#scalar-smallint-math","text":"This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; Add mixed scalar objects and postgres scalar values select (-1::smallint)::scalar + 1::smallint; ?column? ---------- i2:0 (1 row) select -1::smallint + (1::smallint)::scalar; ?column? ---------- 0 (1 row)","title":"Scalar 'smallint' Math"},{"location":"test_scalar_math_i4/","text":"Scalar 'integer' Math This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; Add mixed scalar objects and postgres scalar values select (-1::integer)::scalar + 1::integer; ?column? ---------- i4:0 (1 row) select -1::integer + (1::integer)::scalar; ?column? ---------- 0 (1 row)","title":"Scalar 'integer' Math"},{"location":"test_scalar_math_i4/#scalar-integer-math","text":"This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; Add mixed scalar objects and postgres scalar values select (-1::integer)::scalar + 1::integer; ?column? ---------- i4:0 (1 row) select -1::integer + (1::integer)::scalar; ?column? ---------- 0 (1 row)","title":"Scalar 'integer' Math"},{"location":"test_scalar_math_i8/","text":"Scalar 'bigint' Math This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; Add mixed scalar objects and postgres scalar values select (-1::bigint)::scalar + 1::bigint; ?column? ---------- i8:0 (1 row) select -1::bigint + (1::bigint)::scalar; ?column? ---------- 0 (1 row)","title":"Scalar 'bigint' Math"},{"location":"test_scalar_math_i8/#scalar-bigint-math","text":"This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; Add mixed scalar objects and postgres scalar values select (-1::bigint)::scalar + 1::bigint; ?column? ---------- i8:0 (1 row) select -1::bigint + (1::bigint)::scalar; ?column? ---------- 0 (1 row)","title":"Scalar 'bigint' Math"},{"location":"test_scalar_op_f4/","text":"Scalar 'float4' Operators This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; Test various scalar math operations with native Postgres types select (1::float4)::scalar + -1::float4; ?column? ------------- f4:0.000000 (1 row) select 1::float4 + (-1::float4)::scalar; ?column? ---------- 0 (1 row) select (1::float4)::scalar - 1::float4; ?column? ------------- f4:0.000000 (1 row) select 1::float4 - (1::float4)::scalar; ?column? ---------- 0 (1 row) select (1::float4)::scalar * -1::float4; ?column? -------------- f4:-1.000000 (1 row) select 1::float4 * (-1::float4)::scalar; ?column? ---------- -1 (1 row) select (1::float4)::scalar / 1::float4; ?column? ------------- f4:1.000000 (1 row) select 1::float4 / (1::float4)::scalar; ?column? ---------- 1 (1 row)","title":"Scalar 'float4' Operators"},{"location":"test_scalar_op_f4/#scalar-float4-operators","text":"This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; Test various scalar math operations with native Postgres types select (1::float4)::scalar + -1::float4; ?column? ------------- f4:0.000000 (1 row) select 1::float4 + (-1::float4)::scalar; ?column? ---------- 0 (1 row) select (1::float4)::scalar - 1::float4; ?column? ------------- f4:0.000000 (1 row) select 1::float4 - (1::float4)::scalar; ?column? ---------- 0 (1 row) select (1::float4)::scalar * -1::float4; ?column? -------------- f4:-1.000000 (1 row) select 1::float4 * (-1::float4)::scalar; ?column? ---------- -1 (1 row) select (1::float4)::scalar / 1::float4; ?column? ------------- f4:1.000000 (1 row) select 1::float4 / (1::float4)::scalar; ?column? ---------- 1 (1 row)","title":"Scalar 'float4' Operators"},{"location":"test_scalar_op_f8/","text":"Scalar 'float8' Operators This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; Test various scalar math operations with native Postgres types select (1::float8)::scalar + -1::float8; ?column? ------------- f8:0.000000 (1 row) select 1::float8 + (-1::float8)::scalar; ?column? ---------- 0 (1 row) select (1::float8)::scalar - 1::float8; ?column? ------------- f8:0.000000 (1 row) select 1::float8 - (1::float8)::scalar; ?column? ---------- 0 (1 row) select (1::float8)::scalar * -1::float8; ?column? -------------- f8:-1.000000 (1 row) select 1::float8 * (-1::float8)::scalar; ?column? ---------- -1 (1 row) select (1::float8)::scalar / 1::float8; ?column? ------------- f8:1.000000 (1 row) select 1::float8 / (1::float8)::scalar; ?column? ---------- 1 (1 row)","title":"Scalar 'float8' Operators"},{"location":"test_scalar_op_f8/#scalar-float8-operators","text":"This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; Test various scalar math operations with native Postgres types select (1::float8)::scalar + -1::float8; ?column? ------------- f8:0.000000 (1 row) select 1::float8 + (-1::float8)::scalar; ?column? ---------- 0 (1 row) select (1::float8)::scalar - 1::float8; ?column? ------------- f8:0.000000 (1 row) select 1::float8 - (1::float8)::scalar; ?column? ---------- 0 (1 row) select (1::float8)::scalar * -1::float8; ?column? -------------- f8:-1.000000 (1 row) select 1::float8 * (-1::float8)::scalar; ?column? ---------- -1 (1 row) select (1::float8)::scalar / 1::float8; ?column? ------------- f8:1.000000 (1 row) select 1::float8 / (1::float8)::scalar; ?column? ---------- 1 (1 row)","title":"Scalar 'float8' Operators"},{"location":"test_scalar_op_i2/","text":"Scalar 'smallint' Operators This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; Test various scalar math operations with native Postgres types select (1::smallint)::scalar + -1::smallint; ?column? ---------- i2:0 (1 row) select 1::smallint + (-1::smallint)::scalar; ?column? ---------- 0 (1 row) select (1::smallint)::scalar - 1::smallint; ?column? ---------- i2:0 (1 row) select 1::smallint - (1::smallint)::scalar; ?column? ---------- 0 (1 row) select (1::smallint)::scalar * -1::smallint; ?column? ---------- i2:-1 (1 row) select 1::smallint * (-1::smallint)::scalar; ?column? ---------- -1 (1 row) select (1::smallint)::scalar / 1::smallint; ?column? ---------- i2:1 (1 row) select 1::smallint / (1::smallint)::scalar; ?column? ---------- 1 (1 row)","title":"Scalar 'smallint' Operators"},{"location":"test_scalar_op_i2/#scalar-smallint-operators","text":"This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; Test various scalar math operations with native Postgres types select (1::smallint)::scalar + -1::smallint; ?column? ---------- i2:0 (1 row) select 1::smallint + (-1::smallint)::scalar; ?column? ---------- 0 (1 row) select (1::smallint)::scalar - 1::smallint; ?column? ---------- i2:0 (1 row) select 1::smallint - (1::smallint)::scalar; ?column? ---------- 0 (1 row) select (1::smallint)::scalar * -1::smallint; ?column? ---------- i2:-1 (1 row) select 1::smallint * (-1::smallint)::scalar; ?column? ---------- -1 (1 row) select (1::smallint)::scalar / 1::smallint; ?column? ---------- i2:1 (1 row) select 1::smallint / (1::smallint)::scalar; ?column? ---------- 1 (1 row)","title":"Scalar 'smallint' Operators"},{"location":"test_scalar_op_i4/","text":"Scalar 'integer' Operators This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; Test various scalar math operations with native Postgres types select (1::integer)::scalar + -1::integer; ?column? ---------- i4:0 (1 row) select 1::integer + (-1::integer)::scalar; ?column? ---------- 0 (1 row) select (1::integer)::scalar - 1::integer; ?column? ---------- i4:0 (1 row) select 1::integer - (1::integer)::scalar; ?column? ---------- 0 (1 row) select (1::integer)::scalar * -1::integer; ?column? ---------- i4:-1 (1 row) select 1::integer * (-1::integer)::scalar; ?column? ---------- -1 (1 row) select (1::integer)::scalar / 1::integer; ?column? ---------- i4:1 (1 row) select 1::integer / (1::integer)::scalar; ?column? ---------- 1 (1 row)","title":"Scalar 'integer' Operators"},{"location":"test_scalar_op_i4/#scalar-integer-operators","text":"This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; Test various scalar math operations with native Postgres types select (1::integer)::scalar + -1::integer; ?column? ---------- i4:0 (1 row) select 1::integer + (-1::integer)::scalar; ?column? ---------- 0 (1 row) select (1::integer)::scalar - 1::integer; ?column? ---------- i4:0 (1 row) select 1::integer - (1::integer)::scalar; ?column? ---------- 0 (1 row) select (1::integer)::scalar * -1::integer; ?column? ---------- i4:-1 (1 row) select 1::integer * (-1::integer)::scalar; ?column? ---------- -1 (1 row) select (1::integer)::scalar / 1::integer; ?column? ---------- i4:1 (1 row) select 1::integer / (1::integer)::scalar; ?column? ---------- 1 (1 row)","title":"Scalar 'integer' Operators"},{"location":"test_scalar_op_i8/","text":"Scalar 'bigint' Operators This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; Test various scalar math operations with native Postgres types select (1::bigint)::scalar + -1::bigint; ?column? ---------- i8:0 (1 row) select 1::bigint + (-1::bigint)::scalar; ?column? ---------- 0 (1 row) select (1::bigint)::scalar - 1::bigint; ?column? ---------- i8:0 (1 row) select 1::bigint - (1::bigint)::scalar; ?column? ---------- 0 (1 row) select (1::bigint)::scalar * -1::bigint; ?column? ---------- i8:-1 (1 row) select 1::bigint * (-1::bigint)::scalar; ?column? ---------- -1 (1 row) select (1::bigint)::scalar / 1::bigint; ?column? ---------- i8:1 (1 row) select 1::bigint / (1::bigint)::scalar; ?column? ---------- 1 (1 row)","title":"Scalar 'bigint' Operators"},{"location":"test_scalar_op_i8/#scalar-bigint-operators","text":"This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; Test various scalar math operations with native Postgres types select (1::bigint)::scalar + -1::bigint; ?column? ---------- i8:0 (1 row) select 1::bigint + (-1::bigint)::scalar; ?column? ---------- 0 (1 row) select (1::bigint)::scalar - 1::bigint; ?column? ---------- i8:0 (1 row) select 1::bigint - (1::bigint)::scalar; ?column? ---------- 0 (1 row) select (1::bigint)::scalar * -1::bigint; ?column? ---------- i8:-1 (1 row) select 1::bigint * (-1::bigint)::scalar; ?column? ---------- -1 (1 row) select (1::bigint)::scalar / 1::bigint; ?column? ---------- i8:1 (1 row) select 1::bigint / (1::bigint)::scalar; ?column? ---------- 1 (1 row)","title":"Scalar 'bigint' Operators"},{"location":"test_vector_header/","text":"Vectors This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; Describe the vector type: \\dT+ vector List of data types Schema | Name | Internal name | Size | Elements | Owner | Access privileges | Description -----------+--------+---------------+------+----------+----------+-------------------+------------- onesparse | vector | vector | var | | postgres | | (1 row) An empty vector can be constructed many ways, but one of the simplest is casting a type code to the matrix type. In this case 'i4' means GrB_INT32. The type codes are intentionally compressed to be as short as possible for smaller pg_dumps. Much of these functions are basically vector versions of the same functions for matrix. See those docs for details: select 'i4'::vector; vector -------- i4[] (1 row) select nvals('i4'::vector); nvals ------- 0 (1 row) select size('i4'::vector); size --------------------- 1152921504606846976 (1 row) select 'i4[]'::vector; vector -------- i4[] (1 row) select nvals('i4[]'::vector); nvals ------- 0 (1 row) select size('i4[]'::vector); size --------------------- 1152921504606846976 (1 row) select 'i4(10)'::vector; vector -------- i4[] (1 row) select nvals('i4(10)'::vector); nvals ------- 0 (1 row) select size('i4(10)'::vector); size ------ 10 (1 row) select 'i4(10)[]'::vector; vector -------- i4[] (1 row) select nvals('i4(10)[]'::vector); nvals ------- 0 (1 row) select size('i4(10)[]'::vector); size ------ 10 (1 row) select 'i4[0:1 1:2 2:3]'::vector; vector ----------------- i4[0:1 1:2 2:3] (1 row) select nvals('i4[0:1 1:2 2:3]'::vector); nvals ------- 3 (1 row) select 'i4(10)[0:1 1:2 2:3]'::vector; vector ----------------- i4[0:1 1:2 2:3] (1 row) select size('i4(10)[0:1 1:2 2:3]'::vector); size ------ 10 (1 row) select size('i4(2)[0:1 1:2 2:3]'::vector); ERROR: INVALID_INDEX GraphBLAS error: GrB_INVALID_INDEX function: GrB_Vector_setElement_INT64 (w, x, row) Row index 2 out of range; must be < 2: Error setting Vector Element LINE 1: select size('i4(2)[0:1 1:2 2:3]'::vector); ^ select ewise_add('i4[0:1 1:2 2:3]'::vector, 'i4[0:1 1:2 2:3]'::vector, 'plus_int32'); ewise_add ----------------- i4[0:2 1:4 2:6] (1 row) select ewise_mult('i4[0:1 1:2 2:3]'::vector, 'i4[0:1 1:2 2:3]'::vector, 'times_int32'); ewise_mult ----------------- i4[0:1 1:4 2:9] (1 row) select ewise_union('i4[0:1 1:2 2:3]'::vector, 42, 'i4[0:1 1:2 2:3]'::vector, 84, 'plus_int32'); ewise_union ----------------- i4[0:2 1:4 2:6] (1 row) select reduce_scalar('i4[0:1 1:2 2:3]'::vector, 'plus_monoid_int32'); reduce_scalar --------------- i4:6 (1 row) select selection('i4[0:1 1:2 2:3]'::vector, 'valuegt_int32', 1); selection ------------- i4[1:2 2:3] (1 row) select apply('i4[1:1 2:2 3:3]'::vector, 'ainv_int32'::unaryop); apply -------------------- i4[1:-1 2:-2 3:-3] (1 row) select wait('i4[0:1 1:2 2:3]'::vector); wait ------ (1 row) select dup('i4[0:1 1:2 2:3]'::vector); dup ----------------- i4[0:1 1:2 2:3] (1 row) select clear('i4[0:1 1:2 2:3]'::vector); clear ------- (1 row)","title":"Vectors"},{"location":"test_vector_header/#vectors","text":"This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING'; create extension if not exists onesparse; Describe the vector type: \\dT+ vector List of data types Schema | Name | Internal name | Size | Elements | Owner | Access privileges | Description -----------+--------+---------------+------+----------+----------+-------------------+------------- onesparse | vector | vector | var | | postgres | | (1 row) An empty vector can be constructed many ways, but one of the simplest is casting a type code to the matrix type. In this case 'i4' means GrB_INT32. The type codes are intentionally compressed to be as short as possible for smaller pg_dumps. Much of these functions are basically vector versions of the same functions for matrix. See those docs for details: select 'i4'::vector; vector -------- i4[] (1 row) select nvals('i4'::vector); nvals ------- 0 (1 row) select size('i4'::vector); size --------------------- 1152921504606846976 (1 row) select 'i4[]'::vector; vector -------- i4[] (1 row) select nvals('i4[]'::vector); nvals ------- 0 (1 row) select size('i4[]'::vector); size --------------------- 1152921504606846976 (1 row) select 'i4(10)'::vector; vector -------- i4[] (1 row) select nvals('i4(10)'::vector); nvals ------- 0 (1 row) select size('i4(10)'::vector); size ------ 10 (1 row) select 'i4(10)[]'::vector; vector -------- i4[] (1 row) select nvals('i4(10)[]'::vector); nvals ------- 0 (1 row) select size('i4(10)[]'::vector); size ------ 10 (1 row) select 'i4[0:1 1:2 2:3]'::vector; vector ----------------- i4[0:1 1:2 2:3] (1 row) select nvals('i4[0:1 1:2 2:3]'::vector); nvals ------- 3 (1 row) select 'i4(10)[0:1 1:2 2:3]'::vector; vector ----------------- i4[0:1 1:2 2:3] (1 row) select size('i4(10)[0:1 1:2 2:3]'::vector); size ------ 10 (1 row) select size('i4(2)[0:1 1:2 2:3]'::vector); ERROR: INVALID_INDEX GraphBLAS error: GrB_INVALID_INDEX function: GrB_Vector_setElement_INT64 (w, x, row) Row index 2 out of range; must be < 2: Error setting Vector Element LINE 1: select size('i4(2)[0:1 1:2 2:3]'::vector); ^ select ewise_add('i4[0:1 1:2 2:3]'::vector, 'i4[0:1 1:2 2:3]'::vector, 'plus_int32'); ewise_add ----------------- i4[0:2 1:4 2:6] (1 row) select ewise_mult('i4[0:1 1:2 2:3]'::vector, 'i4[0:1 1:2 2:3]'::vector, 'times_int32'); ewise_mult ----------------- i4[0:1 1:4 2:9] (1 row) select ewise_union('i4[0:1 1:2 2:3]'::vector, 42, 'i4[0:1 1:2 2:3]'::vector, 84, 'plus_int32'); ewise_union ----------------- i4[0:2 1:4 2:6] (1 row) select reduce_scalar('i4[0:1 1:2 2:3]'::vector, 'plus_monoid_int32'); reduce_scalar --------------- i4:6 (1 row) select selection('i4[0:1 1:2 2:3]'::vector, 'valuegt_int32', 1); selection ------------- i4[1:2 2:3] (1 row) select apply('i4[1:1 2:2 3:3]'::vector, 'ainv_int32'::unaryop); apply -------------------- i4[1:-1 2:-2 3:-3] (1 row) select wait('i4[0:1 1:2 2:3]'::vector); wait ------ (1 row) select dup('i4[0:1 1:2 2:3]'::vector); dup ----------------- i4[0:1 1:2 2:3] (1 row) select clear('i4[0:1 1:2 2:3]'::vector); clear ------- (1 row)","title":"Vectors"}]}