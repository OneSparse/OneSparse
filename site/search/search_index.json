{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to OneSparse Postgres OneSparse is a Postgres extension that bind the powerful SuiteSparse:GraphBLAS Linear Algebra library, exposing it's functionality and new types, functions and operators in Postgres. TLDR; Docker Demo Start the onesparse demo docker container, substitute suitable password and container name: docker run -d -e POSTGRES_PASSWORD=password -it --name onesparse-demo-container onesparse/onesparse:0.1.0 The container will start detached in the background, verify it's running with 'docker ps'. Now exec a psql process to interact with the container: $ docker exec -u postgres -it onesparse-demo-container psql psql (17.0 (Debian 17.0-1.pgdg120+1)) Type \"help\" for help. postgres=# select 'i4'::matrix; matrix -------- i4[] (1 row) postgres=# See the doctests for some examples for creating matrices and vectors. You can verify the doctests with docker using: $ docker exec -u postgres -it onesparse-demo-container make installcheck Summary OneSparse Postgres extends the PostgreSQL object relational database with the state-of-the-art SuiteSparse:GraphBLAS high performance dense/sparse linear algebra library. SuiteSparse contains thousands of algorithms optimizing tasks for algebraic graph traversal, machine learning, AI, science, and engineering. SuiteSparse's powerful built-in JIT compiler can target multiple hardware architectures, including GPUs, with no changes to your code. Join us in the OneSparse Discussions Board and say hi!.","title":"Welcome to OneSparse Postgres"},{"location":"#welcome-to-onesparse-postgres","text":"OneSparse is a Postgres extension that bind the powerful SuiteSparse:GraphBLAS Linear Algebra library, exposing it's functionality and new types, functions and operators in Postgres.","title":"Welcome to OneSparse Postgres"},{"location":"#tldr-docker-demo","text":"Start the onesparse demo docker container, substitute suitable password and container name: docker run -d -e POSTGRES_PASSWORD=password -it --name onesparse-demo-container onesparse/onesparse:0.1.0 The container will start detached in the background, verify it's running with 'docker ps'. Now exec a psql process to interact with the container: $ docker exec -u postgres -it onesparse-demo-container psql psql (17.0 (Debian 17.0-1.pgdg120+1)) Type \"help\" for help. postgres=# select 'i4'::matrix; matrix -------- i4[] (1 row) postgres=# See the doctests for some examples for creating matrices and vectors. You can verify the doctests with docker using: $ docker exec -u postgres -it onesparse-demo-container make installcheck","title":"TLDR; Docker Demo"},{"location":"#summary","text":"OneSparse Postgres extends the PostgreSQL object relational database with the state-of-the-art SuiteSparse:GraphBLAS high performance dense/sparse linear algebra library. SuiteSparse contains thousands of algorithms optimizing tasks for algebraic graph traversal, machine learning, AI, science, and engineering. SuiteSparse's powerful built-in JIT compiler can target multiple hardware architectures, including GPUs, with no changes to your code. Join us in the OneSparse Discussions Board and say hi!.","title":"Summary"},{"location":"test_matrix_header/","text":"Matrix This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure the extension is installed. create extension if not exists onesparse ; The matrix data type wraps a SuiteSparse GrB_Matrix handle and delegates functions from SQL to the library through instances of this type. List of data types \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Schema \u2502 Name \u2502 Internal name \u2502 Size \u2502 Elements \u2502 Owner \u2502 Access privileges \u2502 Description \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 onesparse \u2502 matrix \u2502 matrix \u2502 var \u2502 \u2502 postgres \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 ( 1 row ) An empty matrix can be constructed many ways, but one of the simplest is casting a type code to the matrix type. In this case int32 means the SuiteSparse type GrB_INT32 . select 'int32' :: matrix ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Another way to create an empty matrix is to use the matrix() constructor function: select matrix ( 'int32' ); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) The above matrices are \"unbounced\", they do not have a fixed number of rows and/or columns. The default possible number of rows and columns is defined by the SuiteSparse library to be GrB_INDEX_MAX which is 2^60 power indexes. For the purposes of this documentation this will be referred to as INDEX_MAX and matrices and vector dimensions that are INDEX_MAX in size are reffered to as \"unbounded\". For matrices with known dimensions, the dimensions can be provided in parentesis after the type code. Here a 10 row by 10 column matrix is created: select 'int32(10:10)' :: matrix ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32(10:10) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Another way to make a new matrix is with the matrix constructor function. select matrix ( 'int32' , 8 , 8 ); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32(8:8) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Either dimension can be ommited, this creates a 10 row by unbounded column matrix. select 'int32(10:)' :: matrix ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32(10:) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) This creates a unbounded row by 10 column matrix. select 'int32(:10)' :: matrix ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32(:10) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Note that in all the above cases the matrices created are empty . They contain no stored elements. The memory needed to hold the matrix contains only stored elements, if there isn't a value stored at a given row or column position, no memory is consumed. This is the \"sparse\" in sparse matrix. This is how it's possible to create an unbounded row by unbounded column matrix without exhausting memory trying to allocate 2^120 entries. All graphblas operations are exposed by a series of functions and operators. Here we see three very common operations, returning the number of rows, the number of columns, and the number of store values. select nrows ( 'int32' :: matrix ), ncols ( 'int32' :: matrix ), nvals ( 'int32' :: matrix ); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nrows \u2502 ncols \u2502 nvals \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1152921504606846976 \u2502 1152921504606846976 \u2502 0 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Above you can see the matrix has unbounded rows and columns (the very large number is the number of possible entries). And the number of stored values is zero. These matrices are empty, they contain no elements. Values can be specified after the type(dimension) prefix as an array of elements between square brackets. Empty brackets imply no elements, so empty square brackets are the same as no square brackets as above: select nrows ( 'int32[]' :: matrix ), ncols ( 'int32[]' :: matrix ), nvals ( 'int32[]' :: matrix ); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nrows \u2502 ncols \u2502 nvals \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1152921504606846976 \u2502 1152921504606846976 \u2502 0 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Elements are specified between square brackets are coordinates of 'row_id:column_id:value' separated by spaces: select 'int32[1:2:1 2:3:2 3:1:3]' :: matrix , 'int32(10:)[1:2:1 2:3:2 3:1:3]' :: matrix , 'int32(:10)[1:2:1 2:3:2 3:3:1]' :: matrix ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 matrix \u2502 matrix \u2502 matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32[1:2:1 2:3:2 3:1:3] \u2502 int32(10:)[1:2:1 2:3:2 3:1:3] \u2502 int32(:10)[1:2:1 2:3:2 3:3:1] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Seeing matrices in this format is pretty hard to understand, there are two helpful functions for visualizing matrices, the first is print which prints the matrix in Below you see the number of rows, columns and spaces for a variety of combinations: select print ( 'int32(8:8)[1:2:1 2:3:2 3:1:3]' :: matrix ) as matrix ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 5 6 7 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 1 \u2502 \u2502 2\u2502 2 \u2502 \u2502 3\u2502 3 \u2502 \u2502 4\u2502 \u2502 \u2502 5\u2502 \u2502 \u2502 6\u2502 \u2502 \u2502 7\u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Above you can see the sparse matrix format of an 8x8 matrix. It's only possible to print matrices that have fixed dimensions of a reasonable size. Another useful function is dot_matrix() This turns a matrix into the Graphviz DOT language that is used to draw graph diagrams: select dot_matrix ( 'int32(8:8)[1:2:1 2:3:2 3:1:3]' :: matrix ) as dot_matrix ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 dot_matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 digraph { \u2502 \u2502 1 -> 2 [ label = \"1\" ] \u2502 \u2502 2 -> 3 [ label = \"2\" ] \u2502 \u2502 3 -> 1 [ label = \"3\" ] \u2502 \u2502 } \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 ( 1 row ) Will generate the following diagram: %3 1 1 2 2 1->2 1 3 3 2->3 2 3->1 3 Another useful function is random_matrix() . This will generate a random matrix provided the type, number of rows, number of columns, and the number of (approximate) values and an optional random seed for deterministic generation: select print(random_matrix(8, 8, 16, seed=> 0.42 , max => 42 )) as random_matrix ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 random_matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 5 6 7 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 6 31 \u2502 \u2502 1\u2502 12 26 \u2502 \u2502 2\u2502 \u2502 \u2502 3\u2502 40 11 15 \u2502 \u2502 4\u2502 7 20 12 22 \u2502 \u2502 5\u2502 1 1 \u2502 \u2502 6\u2502 17 \u2502 \u2502 7\u2502 20 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) %3 0 0 3 3 0->3 6 4 4 0->4 31 1 1 3->1 40 7 7 3->7 15 5 5 3->5 11 4->3 20 4->4 12 2 2 4->2 7 6 6 4->6 22 1->4 12 1->7 26 7->2 20 5->0 1 5->6 1 6->3 17 Test Fixtures Let's get a test fixture table with a couple matrix and vector columns so that we can do some operations without tediously repeating the literal syntax. These matrices and vectors are construction with random_matrix() show above, and the random_vector() function: select print ( a ) as a , print ( b ) as b , print ( u ) as u , print ( v ) as v from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 b \u2502 u \u2502 v \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 \u2502 0 1 2 3 4 \u2502 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 0\u2502 \u2502 0\u2502 5 \u2502 0\u2502 4 \u2502 \u2502 1\u2502 8 3 \u2502 1\u2502 \u2502 1\u2502 \u2502 1\u2502 1 \u2502 \u2502 2\u2502 2 5 \u2502 2\u2502 5 8 4 \u2502 2\u2502 \u2502 2\u2502 \u2502 \u2502 3\u2502 1 \u2502 3\u2502 4 7 5 \u2502 3\u2502 \u2502 3\u2502 4 \u2502 \u2502 4\u2502 7 5 \u2502 4\u2502 8 \u2502 4\u2502 0 \u2502 4\u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 0 1 2 3 4 \u2502 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 7 4 \u2502 0\u2502 8 \u2502 0\u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 5 \u2502 1\u2502 3 \u2502 1\u2502 0 \u2502 1\u2502 \u2502 \u2502 2\u2502 0 4 10 5 \u2502 2\u2502 4 1 \u2502 2\u2502 3 \u2502 2\u2502 4 \u2502 \u2502 3\u2502 2 1 \u2502 3\u2502 1 5 10 \u2502 3\u2502 2 \u2502 3\u2502 \u2502 \u2502 4\u2502 9 5 \u2502 4\u2502 1 9 1 \u2502 4\u2502 5 \u2502 4\u2502 3 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 0 1 2 3 4 \u2502 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 2 \u2502 0\u2502 10 6 8 6 \u2502 0\u2502 \u2502 0\u2502 5 \u2502 \u2502 1\u2502 2 \u2502 1\u2502 0 8 \u2502 1\u2502 \u2502 1\u2502 \u2502 \u2502 2\u2502 \u2502 2\u2502 \u2502 2\u2502 1 \u2502 2\u2502 3 \u2502 \u2502 3\u2502 5 1 \u2502 3\u2502 \u2502 3\u2502 \u2502 3\u2502 4 \u2502 \u2502 4\u2502 9 \u2502 4\u2502 7 3 \u2502 4\u2502 \u2502 4\u2502 3 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (3 rows) Element-wise operations The GraphBLAS API has elementwise operations on matrices that operate pairs of matrices. eadd computes the element-wise \u201caddition\u201d of two matrices A and B, element-wise using any binary operator. Elements present on both sides of the operation are included in the result. select print ( a ) as a , binaryop , print ( b ) as b , print ( eadd ( A , B , binaryop )) as union from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 binaryop \u2502 b \u2502 union \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 \u2502 times_int16 \u2502 0 1 2 3 4 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 \u2502 0\u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 8 3 \u2502 \u2502 1\u2502 \u2502 1\u2502 8 3 \u2502 \u2502 2\u2502 2 5 \u2502 \u2502 2\u2502 5 8 4 \u2502 2\u2502 5 2 8 5 4 \u2502 \u2502 3\u2502 1 \u2502 \u2502 3\u2502 4 7 5 \u2502 3\u2502 4 7 5 \u2502 \u2502 4\u2502 7 5 \u2502 \u2502 4\u2502 8 \u2502 4\u2502 7 8 5 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 times_int32 \u2502 0 1 2 3 4 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 7 4 \u2502 \u2502 0\u2502 8 \u2502 0\u2502 0 56 4 \u2502 \u2502 1\u2502 5 \u2502 \u2502 1\u2502 3 \u2502 1\u2502 15 \u2502 \u2502 2\u2502 0 4 10 5 \u2502 \u2502 2\u2502 4 1 \u2502 2\u2502 0 4 10 5 1 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 1 5 10 \u2502 3\u2502 2 1 5 10 \u2502 \u2502 4\u2502 9 5 \u2502 \u2502 4\u2502 1 9 1 \u2502 4\u2502 9 45 1 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 times_int64 \u2502 0 1 2 3 4 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 2 \u2502 \u2502 0\u2502 10 6 8 6 \u2502 0\u2502 10 6 16 6 \u2502 \u2502 1\u2502 2 \u2502 \u2502 1\u2502 0 8 \u2502 1\u2502 2 0 8 \u2502 \u2502 2\u2502 \u2502 \u2502 2\u2502 \u2502 2\u2502 \u2502 \u2502 3\u2502 5 1 \u2502 \u2502 3\u2502 \u2502 3\u2502 5 1 \u2502 \u2502 4\u2502 9 \u2502 \u2502 4\u2502 7 3 \u2502 4\u2502 7 3 9 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (3 rows) emult multiplies elements of two matrices, taking only the intersection of common elements in both matrices, if an element is missing from either the left or right side, it is ommited from the result: select print ( a ) as a , binaryop , print ( b ) as b , print ( emult ( A , B , binaryop )) as intersect from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 binaryop \u2502 b \u2502 intersect \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 \u2502 times_int16 \u2502 0 1 2 3 4 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 \u2502 0\u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 8 3 \u2502 \u2502 1\u2502 \u2502 1\u2502 \u2502 \u2502 2\u2502 2 5 \u2502 \u2502 2\u2502 5 8 4 \u2502 2\u2502 \u2502 \u2502 3\u2502 1 \u2502 \u2502 3\u2502 4 7 5 \u2502 3\u2502 5 \u2502 \u2502 4\u2502 7 5 \u2502 \u2502 4\u2502 8 \u2502 4\u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 times_int32 \u2502 0 1 2 3 4 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 7 4 \u2502 \u2502 0\u2502 8 \u2502 0\u2502 56 \u2502 \u2502 1\u2502 5 \u2502 \u2502 1\u2502 3 \u2502 1\u2502 15 \u2502 \u2502 2\u2502 0 4 10 5 \u2502 \u2502 2\u2502 4 1 \u2502 2\u2502 0 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 1 5 10 \u2502 3\u2502 10 \u2502 \u2502 4\u2502 9 5 \u2502 \u2502 4\u2502 1 9 1 \u2502 4\u2502 9 45 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 times_int64 \u2502 0 1 2 3 4 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 2 \u2502 \u2502 0\u2502 10 6 8 6 \u2502 0\u2502 16 \u2502 \u2502 1\u2502 2 \u2502 \u2502 1\u2502 0 8 \u2502 1\u2502 \u2502 \u2502 2\u2502 \u2502 \u2502 2\u2502 \u2502 2\u2502 \u2502 \u2502 3\u2502 5 1 \u2502 \u2502 3\u2502 \u2502 3\u2502 \u2502 \u2502 4\u2502 9 \u2502 \u2502 4\u2502 7 3 \u2502 4\u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (3 rows) eunion is like eadd but differs in how the binary op is applied. A pair of scalars, alpha and beta define the inputs to the operator when entries are present in one matrix but not the other. select print ( a ) as a , binaryop , print ( b ) as b , print ( eunion ( A , 3 , B , 4 , binaryop )) as union from test_fixture ; ERROR: function eunion(matrix, integer, matrix, integer, binaryop) does not exist LINE 1: ...ect print(a) as a, binaryop, print(b) as b, print(eunion(A, ... ^ HINT: No function matches the given name and argument types. You might need to add explicit type casts. The entire matrix can be reduced to a scalar value: select print ( a ) as a , reduce_scalar ( a , monoid ) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 reduce_scalar \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 \u2502 int32:31 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 0\u2502 \u2502 \u2502 \u2502 1\u2502 8 3 \u2502 \u2502 \u2502 2\u2502 2 5 \u2502 \u2502 \u2502 3\u2502 1 \u2502 \u2502 \u2502 4\u2502 7 5 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 int32:52 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 0\u2502 0 7 4 \u2502 \u2502 \u2502 1\u2502 5 \u2502 \u2502 \u2502 2\u2502 0 4 10 5 \u2502 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 \u2502 4\u2502 9 5 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 int32:19 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 0\u2502 2 \u2502 \u2502 \u2502 1\u2502 2 \u2502 \u2502 \u2502 2\u2502 \u2502 \u2502 \u2502 3\u2502 5 1 \u2502 \u2502 \u2502 4\u2502 9 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (3 rows) The matrix can also be reduced to a column vector: select print ( a ) as a , monoid , print ( reduce_vector ( a , monoid )) as reduce_vector from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 monoid \u2502 reduce_vector \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 \u2502 plus_monoid_int16 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 8 3 \u2502 \u2502 1\u2502 11 \u2502 \u2502 2\u2502 2 5 \u2502 \u2502 2\u2502 7 \u2502 \u2502 3\u2502 1 \u2502 \u2502 3\u2502 1 \u2502 \u2502 4\u2502 7 5 \u2502 \u2502 4\u2502 12 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 plus_monoid_int32 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 7 4 \u2502 \u2502 0\u2502 11 \u2502 \u2502 1\u2502 5 \u2502 \u2502 1\u2502 5 \u2502 \u2502 2\u2502 0 4 10 5 \u2502 \u2502 2\u2502 19 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 3 \u2502 \u2502 4\u2502 9 5 \u2502 \u2502 4\u2502 14 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 plus_monoid_int64 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 2 \u2502 \u2502 0\u2502 2 \u2502 \u2502 1\u2502 2 \u2502 \u2502 1\u2502 2 \u2502 \u2502 2\u2502 \u2502 \u2502 2\u2502 \u2502 \u2502 3\u2502 5 1 \u2502 \u2502 3\u2502 6 \u2502 \u2502 4\u2502 9 \u2502 \u2502 4\u2502 9 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (3 rows) To reduce a row vector, specify that the input should be transposed with the descriptor t0 : select print(a) as a, monoid, print(reduce_vector(a, monoid, descriptor=> 't0' )) as transpose_reduce_vector from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 monoid \u2502 transpose_reduce_vector \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 \u2502 plus_monoid_int16 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 8 3 \u2502 \u2502 1\u2502 2 \u2502 \u2502 2\u2502 2 5 \u2502 \u2502 2\u2502 7 \u2502 \u2502 3\u2502 1 \u2502 \u2502 3\u2502 13 \u2502 \u2502 4\u2502 7 5 \u2502 \u2502 4\u2502 9 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 plus_monoid_int32 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 7 4 \u2502 \u2502 0\u2502 2 \u2502 \u2502 1\u2502 5 \u2502 \u2502 1\u2502 18 \u2502 \u2502 2\u2502 0 4 10 5 \u2502 \u2502 2\u2502 22 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 9 \u2502 \u2502 4\u2502 9 5 \u2502 \u2502 4\u2502 1 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 plus_monoid_int64 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 2 \u2502 \u2502 0\u2502 2 \u2502 \u2502 1\u2502 2 \u2502 \u2502 1\u2502 \u2502 \u2502 2\u2502 \u2502 \u2502 2\u2502 11 \u2502 \u2502 3\u2502 5 1 \u2502 \u2502 3\u2502 5 \u2502 \u2502 4\u2502 9 \u2502 \u2502 4\u2502 1 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (3 rows) Matrix Multiplication (referred to here as A @ B) is the heart of linear algebra. All matrix multiplication happens over a semiring. For the most common form of matrix multiplication, the outer opperation is to multiply coresponding elements with the \"times\" operator and then reduce those products with the \"plus\" operator. This is called the plus_times semiring: select print ( a ) as a , semiring , print ( b ) as b , print ( mxm ( a , b , semiring )) as mxm from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 semiring \u2502 b \u2502 mxm \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 \u2502 plus_times_int16 \u2502 0 1 2 3 4 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 \u2502 0\u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 8 3 \u2502 \u2502 1\u2502 \u2502 1\u2502 32 56 24 40 \u2502 \u2502 2\u2502 2 5 \u2502 \u2502 2\u2502 5 8 4 \u2502 2\u2502 20 35 25 \u2502 \u2502 3\u2502 1 \u2502 \u2502 3\u2502 4 7 5 \u2502 3\u2502 8 \u2502 \u2502 4\u2502 7 5 \u2502 \u2502 4\u2502 8 \u2502 4\u2502 35 56 40 28 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 plus_times_int32 \u2502 0 1 2 3 4 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 7 4 \u2502 \u2502 0\u2502 8 \u2502 0\u2502 28 4 20 47 \u2502 \u2502 1\u2502 5 \u2502 \u2502 1\u2502 3 \u2502 1\u2502 15 \u2502 \u2502 2\u2502 0 4 10 5 \u2502 \u2502 2\u2502 4 1 \u2502 2\u2502 40 17 0 25 60 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 1 5 10 \u2502 3\u2502 1 25 1 \u2502 \u2502 4\u2502 9 5 \u2502 \u2502 4\u2502 1 9 1 \u2502 4\u2502 20 27 5 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 plus_times_int64 \u2502 0 1 2 3 4 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 2 \u2502 \u2502 0\u2502 10 6 8 6 \u2502 0\u2502 \u2502 \u2502 1\u2502 2 \u2502 \u2502 1\u2502 0 8 \u2502 1\u2502 20 12 16 12 \u2502 \u2502 2\u2502 \u2502 \u2502 2\u2502 \u2502 2\u2502 \u2502 \u2502 3\u2502 5 1 \u2502 \u2502 3\u2502 \u2502 3\u2502 7 3 \u2502 \u2502 4\u2502 9 \u2502 \u2502 4\u2502 7 3 \u2502 4\u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (3 rows) AxB can also be done with the @ operator, mimicking the Python syntax. The default semiring for numeric types is plus_times . select print ( a ) as a , '@' as \"@\" , print ( b ) as b , print ( a @ b ) as mxm from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 @ \u2502 b \u2502 mxm \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 \u2502 @ \u2502 0 1 2 3 4 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 \u2502 0\u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 8 3 \u2502 \u2502 1\u2502 \u2502 1\u2502 3 3 4 3 \u2502 \u2502 2\u2502 2 5 \u2502 \u2502 2\u2502 5 8 4 \u2502 2\u2502 3 3 3 \u2502 \u2502 3\u2502 1 \u2502 \u2502 3\u2502 4 7 5 \u2502 3\u2502 4 \u2502 \u2502 4\u2502 7 5 \u2502 \u2502 4\u2502 8 \u2502 4\u2502 2 2 4 2 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 @ \u2502 0 1 2 3 4 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 7 4 \u2502 \u2502 0\u2502 8 \u2502 0\u2502 2 3 3 3 \u2502 \u2502 1\u2502 5 \u2502 \u2502 1\u2502 3 \u2502 1\u2502 1 \u2502 \u2502 2\u2502 0 4 10 5 \u2502 \u2502 2\u2502 4 1 \u2502 2\u2502 2 3 0 3 3 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 1 5 10 \u2502 3\u2502 4 4 4 \u2502 \u2502 4\u2502 9 5 \u2502 \u2502 4\u2502 1 9 1 \u2502 4\u2502 2 1 2 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 @ \u2502 0 1 2 3 4 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 2 \u2502 \u2502 0\u2502 10 6 8 6 \u2502 0\u2502 \u2502 \u2502 1\u2502 2 \u2502 \u2502 1\u2502 0 8 \u2502 1\u2502 0 0 0 0 \u2502 \u2502 2\u2502 \u2502 \u2502 2\u2502 \u2502 2\u2502 \u2502 \u2502 3\u2502 5 1 \u2502 \u2502 3\u2502 \u2502 3\u2502 4 4 \u2502 \u2502 4\u2502 9 \u2502 \u2502 4\u2502 7 3 \u2502 4\u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (3 rows) Matrices can be multipled by vectors on the right taking the linear combination of the matrices columns using the vectors elements as coefficients: select print ( a ), semiring , print ( u ), print ( mxv ( a , u , semiring )) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 print \u2502 semiring \u2502 print \u2502 print \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 \u2502 plus_times_int16 \u2502 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 \u2502 0\u2502 5 \u2502 0\u2502 \u2502 \u2502 1\u2502 8 3 \u2502 \u2502 1\u2502 \u2502 1\u2502 0 \u2502 \u2502 2\u2502 2 5 \u2502 \u2502 2\u2502 \u2502 2\u2502 \u2502 \u2502 3\u2502 1 \u2502 \u2502 3\u2502 \u2502 3\u2502 0 \u2502 \u2502 4\u2502 7 5 \u2502 \u2502 4\u2502 0 \u2502 4\u2502 0 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 plus_times_int32 \u2502 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 7 4 \u2502 \u2502 0\u2502 \u2502 0\u2502 29 \u2502 \u2502 1\u2502 5 \u2502 \u2502 1\u2502 0 \u2502 1\u2502 0 \u2502 \u2502 2\u2502 0 4 10 5 \u2502 \u2502 2\u2502 3 \u2502 2\u2502 40 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 2 \u2502 3\u2502 5 \u2502 \u2502 4\u2502 9 5 \u2502 \u2502 4\u2502 5 \u2502 4\u2502 15 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 plus_times_int64 \u2502 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 2 \u2502 \u2502 0\u2502 \u2502 0\u2502 2 \u2502 \u2502 1\u2502 2 \u2502 \u2502 1\u2502 \u2502 1\u2502 \u2502 \u2502 2\u2502 \u2502 \u2502 2\u2502 1 \u2502 2\u2502 \u2502 \u2502 3\u2502 5 1 \u2502 \u2502 3\u2502 \u2502 3\u2502 \u2502 \u2502 4\u2502 9 \u2502 \u2502 4\u2502 \u2502 4\u2502 9 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (3 rows) 'mxv' is also supported by the @ operator: select print ( a ), '@' , print ( u ), print ( a @ u ) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 print \u2502 ?column? \u2502 print \u2502 print \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 \u2502 @ \u2502 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 \u2502 0\u2502 5 \u2502 0\u2502 \u2502 \u2502 1\u2502 8 3 \u2502 \u2502 1\u2502 \u2502 1\u2502 4 \u2502 \u2502 2\u2502 2 5 \u2502 \u2502 2\u2502 \u2502 2\u2502 \u2502 \u2502 3\u2502 1 \u2502 \u2502 3\u2502 \u2502 3\u2502 4 \u2502 \u2502 4\u2502 7 5 \u2502 \u2502 4\u2502 0 \u2502 4\u2502 4 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 @ \u2502 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 7 4 \u2502 \u2502 0\u2502 \u2502 0\u2502 1 \u2502 \u2502 1\u2502 5 \u2502 \u2502 1\u2502 0 \u2502 1\u2502 1 \u2502 \u2502 2\u2502 0 4 10 5 \u2502 \u2502 2\u2502 3 \u2502 2\u2502 1 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 2 \u2502 3\u2502 4 \u2502 \u2502 4\u2502 9 5 \u2502 \u2502 4\u2502 5 \u2502 4\u2502 1 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 @ \u2502 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 2 \u2502 \u2502 0\u2502 \u2502 0\u2502 2 \u2502 \u2502 1\u2502 2 \u2502 \u2502 1\u2502 \u2502 1\u2502 \u2502 \u2502 2\u2502 \u2502 \u2502 2\u2502 1 \u2502 2\u2502 \u2502 \u2502 3\u2502 5 1 \u2502 \u2502 3\u2502 \u2502 3\u2502 \u2502 \u2502 4\u2502 9 \u2502 \u2502 4\u2502 \u2502 4\u2502 2 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (3 rows) Matrices can be multipled by vectors on the right taking the linear combination of the matrices rows using the vectors elements as coefficients: select print ( v ), semiring , print ( b ), print ( vxm ( v , b , semiring )) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 print \u2502 semiring \u2502 print \u2502 print \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 plus_times_int16 \u2502 0 1 2 3 4 \u2502 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 4 \u2502 \u2502 0\u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 1 \u2502 \u2502 1\u2502 \u2502 1\u2502 16 \u2502 \u2502 2\u2502 \u2502 \u2502 2\u2502 5 8 4 \u2502 2\u2502 28 \u2502 \u2502 3\u2502 4 \u2502 \u2502 3\u2502 4 7 5 \u2502 3\u2502 \u2502 \u2502 4\u2502 \u2502 \u2502 4\u2502 8 \u2502 4\u2502 20 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 plus_times_int32 \u2502 0 1 2 3 4 \u2502 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 \u2502 0\u2502 8 \u2502 0\u2502 16 \u2502 \u2502 1\u2502 \u2502 \u2502 1\u2502 3 \u2502 1\u2502 3 \u2502 \u2502 2\u2502 4 \u2502 \u2502 2\u2502 4 1 \u2502 2\u2502 27 \u2502 \u2502 3\u2502 \u2502 \u2502 3\u2502 1 5 10 \u2502 3\u2502 3 \u2502 \u2502 4\u2502 3 \u2502 \u2502 4\u2502 1 9 1 \u2502 4\u2502 4 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 plus_times_int64 \u2502 0 1 2 3 4 \u2502 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 5 \u2502 \u2502 0\u2502 10 6 8 6 \u2502 0\u2502 71 \u2502 \u2502 1\u2502 \u2502 \u2502 1\u2502 0 8 \u2502 1\u2502 39 \u2502 \u2502 2\u2502 3 \u2502 \u2502 2\u2502 \u2502 2\u2502 40 \u2502 \u2502 3\u2502 4 \u2502 \u2502 3\u2502 \u2502 3\u2502 30 \u2502 \u2502 4\u2502 3 \u2502 \u2502 4\u2502 7 3 \u2502 4\u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (3 rows) 'vxm' is also supported by the @ operator: select print ( v ), '@' , print ( b ), print ( v @ b ) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 print \u2502 ?column? \u2502 print \u2502 print \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 @ \u2502 0 1 2 3 4 \u2502 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 4 \u2502 \u2502 0\u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 1 \u2502 \u2502 1\u2502 \u2502 1\u2502 3 \u2502 \u2502 2\u2502 \u2502 \u2502 2\u2502 5 8 4 \u2502 2\u2502 3 \u2502 \u2502 3\u2502 4 \u2502 \u2502 3\u2502 4 7 5 \u2502 3\u2502 \u2502 \u2502 4\u2502 \u2502 \u2502 4\u2502 8 \u2502 4\u2502 3 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 @ \u2502 0 1 2 3 4 \u2502 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 \u2502 0\u2502 8 \u2502 0\u2502 2 \u2502 \u2502 1\u2502 \u2502 \u2502 1\u2502 3 \u2502 1\u2502 4 \u2502 \u2502 2\u2502 4 \u2502 \u2502 2\u2502 4 1 \u2502 2\u2502 4 \u2502 \u2502 3\u2502 \u2502 \u2502 3\u2502 1 5 10 \u2502 3\u2502 4 \u2502 \u2502 4\u2502 3 \u2502 \u2502 4\u2502 1 9 1 \u2502 4\u2502 2 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 @ \u2502 0 1 2 3 4 \u2502 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 5 \u2502 \u2502 0\u2502 10 6 8 6 \u2502 0\u2502 4 \u2502 \u2502 1\u2502 \u2502 \u2502 1\u2502 0 8 \u2502 1\u2502 4 \u2502 \u2502 2\u2502 3 \u2502 \u2502 2\u2502 \u2502 2\u2502 0 \u2502 \u2502 3\u2502 4 \u2502 \u2502 3\u2502 \u2502 3\u2502 0 \u2502 \u2502 4\u2502 3 \u2502 \u2502 4\u2502 7 3 \u2502 4\u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (3 rows) The selection method calls the GrB_select() API function. The name selection was chosen not to conflict with the SQL keyword select . Selection provides a conditional operator called an indexunaryop and a parameter for the operator to use to compare elements in the matrix. Below, all elements with values greater than 50 are returned: select print ( a ), indexunaryop , print ( selection ( a , indexunaryop , 50 )) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 print \u2502 indexunaryop \u2502 print \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 \u2502 valuegt_int16 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 8 3 \u2502 \u2502 1\u2502 \u2502 \u2502 2\u2502 2 5 \u2502 \u2502 2\u2502 \u2502 \u2502 3\u2502 1 \u2502 \u2502 3\u2502 \u2502 \u2502 4\u2502 7 5 \u2502 \u2502 4\u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 valuegt_int32 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 7 4 \u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 5 \u2502 \u2502 1\u2502 \u2502 \u2502 2\u2502 0 4 10 5 \u2502 \u2502 2\u2502 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 \u2502 \u2502 4\u2502 9 5 \u2502 \u2502 4\u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 valuegt_int64 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 2 \u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 2 \u2502 \u2502 1\u2502 \u2502 \u2502 2\u2502 \u2502 \u2502 2\u2502 \u2502 \u2502 3\u2502 5 1 \u2502 \u2502 3\u2502 \u2502 \u2502 4\u2502 9 \u2502 \u2502 4\u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (3 rows) apply takes an operator of type unaryop and applies it to every element of the matrix. The 'ainv_int32' returned the additive inverse (the negative value for integers) of every element: select print ( a ), unaryop , print ( apply ( a , unaryop )) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 print \u2502 unaryop \u2502 print \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 \u2502 ainv_int16 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 8 3 \u2502 \u2502 1\u2502 -8 -3 \u2502 \u2502 2\u2502 2 5 \u2502 \u2502 2\u2502 -2 -5 \u2502 \u2502 3\u2502 1 \u2502 \u2502 3\u2502 -1 \u2502 \u2502 4\u2502 7 5 \u2502 \u2502 4\u2502 -7 -5 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 ainv_int32 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 7 4 \u2502 \u2502 0\u2502 0 -7 -4 \u2502 \u2502 1\u2502 5 \u2502 \u2502 1\u2502 -5 \u2502 \u2502 2\u2502 0 4 10 5 \u2502 \u2502 2\u2502 0 -4-10 -5 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 -2 -1 \u2502 \u2502 4\u2502 9 5 \u2502 \u2502 4\u2502 -9 -5 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 ainv_int64 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 2 \u2502 \u2502 0\u2502 -2 \u2502 \u2502 1\u2502 2 \u2502 \u2502 1\u2502 -2 \u2502 \u2502 2\u2502 \u2502 \u2502 2\u2502 \u2502 \u2502 3\u2502 5 1 \u2502 \u2502 3\u2502 -5 -1 \u2502 \u2502 4\u2502 9 \u2502 \u2502 4\u2502 -9 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (3 rows) Elements can be set individually with set_element , the modified input is returned: select print ( set_element ( a , 4 , 4 , 4 )) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 print \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 8 3 \u2502 \u2502 2\u2502 2 5 \u2502 \u2502 3\u2502 1 \u2502 \u2502 4\u2502 7 4 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 7 4 \u2502 \u2502 1\u2502 5 \u2502 \u2502 2\u2502 0 4 10 5 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 4\u2502 9 5 4 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 2 \u2502 \u2502 1\u2502 2 \u2502 \u2502 2\u2502 \u2502 \u2502 3\u2502 5 1 \u2502 \u2502 4\u2502 9 4 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (3 rows) Scalar elements can be extracted individually with get_element select get_element ( a , 3 , 3 ) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 get_element \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int \u2502 \u2502 int \u2502 \u2502 int32:5 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (3 rows) The print function returns a descripton of the matrix from SuiteSparse. select info ( a ) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 info \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 \u2502 5x5 GraphBLAS int32_t matrix, bitmap by row \u2502 \u2502 A-> matrix , 7 entries , memory : 357 bytes \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 5 x5 GraphBLAS int32_t matrix , bitmap by row \u2502 \u2502 A-> matrix , 12 entries , memory : 357 bytes \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 5 x5 GraphBLAS int32_t matrix , bitmap by row \u2502 \u2502 A-> matrix , 5 entries , memory : 357 bytes \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 ( 3 rows ) The print function takes an optional \"level\" argument that defaults to 1 which is a short summary. select info ( a , 5 ) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 info \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 \u2502 5x5 GraphBLAS int32_t matrix, bitmap by row \u2502 \u2502 A-> matrix , 7 entries , memory : 357 bytes \u2502 \u2502 \u2502 \u2502 ( 1 , 3 ) 8 \u2502 \u2502 ( 1 , 4 ) 3 \u2502 \u2502 ( 2 , 1 ) 2 \u2502 \u2502 ( 2 , 3 ) 5 \u2502 \u2502 ( 3 , 4 ) 1 \u2502 \u2502 ( 4 , 2 ) 7 \u2502 \u2502 ( 4 , 4 ) 5 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 5 x5 GraphBLAS int32_t matrix , bitmap by row \u2502 \u2502 A-> matrix , 12 entries , memory : 357 bytes \u2502 \u2502 \u2502 \u2502 ( 0 , 1 ) 0 \u2502 \u2502 ( 0 , 2 ) 7 \u2502 \u2502 ( 0 , 3 ) 4 \u2502 \u2502 ( 1 , 1 ) 5 \u2502 \u2502 ( 2 , 0 ) 0 \u2502 \u2502 ( 2 , 1 ) 4 \u2502 \u2502 ( 2 , 2 ) 10 \u2502 \u2502 ( 2 , 3 ) 5 \u2502 \u2502 ( 3 , 0 ) 2 \u2502 \u2502 ( 3 , 4 ) 1 \u2502 \u2502 ( 4 , 1 ) 9 \u2502 \u2502 ( 4 , 2 ) 5 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 5 x5 GraphBLAS int32_t matrix , bitmap by row \u2502 \u2502 A-> matrix , 5 entries , memory : 357 bytes \u2502 \u2502 \u2502 \u2502 ( 0 , 2 ) 2 \u2502 \u2502 ( 1 , 0 ) 2 \u2502 \u2502 ( 3 , 3 ) 5 \u2502 \u2502 ( 3 , 4 ) 1 \u2502 \u2502 ( 4 , 2 ) 9 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 ( 3 rows ) The dup function duplicates a matrix returning a new matrix object with the same values: select dup ( a ) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 dup \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32(5:5)[1:3:8 1:4:3 2:1:2 2:3:5 3:4:1 4:2:7 4:4:5] \u2502 \u2502 int32(5:5)[0:1:0 0:2:7 0:3:4 1:1:5 2:0:0 2:1:4 2:2:10 2:3:5 3:0:2 3:4:1 4:1:9 4:2:5] \u2502 \u2502 int32(5:5)[0:2:2 1:0:2 3:3:5 3:4:1 4:2:9] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (3 rows) The wait method is used to \"complete\" a matrix, which may have pending operations waiting to be performed when using the default SuiteSparse non-blocking mode. As a side effect, wait will sort the elements of the input: select wait ( 'int32[2:2:2 3:3:3 1:1:1]' :: matrix ); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 wait \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32[1:1:1 2:2:2 3:3:3] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) The clear function clears the matrix of all elements and returns the same object, but empty. The dimensions do not change: select clear ( 'int32[1:1:1 2:2:2 3:3:3]' :: matrix ); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 clear \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Extra tests This documentation also forms the basis for the onesparse tests, These tests run the documentation against a live server, all the above results are automatically generated. select nrows ( 'int32(10)[1:1:1 2:2:2 3:3:3]' :: matrix ); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nrows \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 10 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select ncols('int32(10)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 ncols \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1152921504606846976 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nvals('int32(10)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nvals \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 3 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nrows('int32(10:)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nrows \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 10 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select ncols('int32(10:)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 ncols \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1152921504606846976 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nvals('int32(10:)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nvals \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 3 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nrows('int32(:10)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nrows \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1152921504606846976 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select ncols('int32(:10)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 ncols \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 10 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nvals('int32(:10)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nvals \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 3 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nrows('int32(10:10)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nrows \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 10 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select ncols('int32(10:10)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 ncols \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 10 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nvals('int32(10:10)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nvals \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 3 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row)","title":"Matrix"},{"location":"test_matrix_header/#matrix","text":"This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure the extension is installed. create extension if not exists onesparse ; The matrix data type wraps a SuiteSparse GrB_Matrix handle and delegates functions from SQL to the library through instances of this type. List of data types \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Schema \u2502 Name \u2502 Internal name \u2502 Size \u2502 Elements \u2502 Owner \u2502 Access privileges \u2502 Description \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 onesparse \u2502 matrix \u2502 matrix \u2502 var \u2502 \u2502 postgres \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 ( 1 row ) An empty matrix can be constructed many ways, but one of the simplest is casting a type code to the matrix type. In this case int32 means the SuiteSparse type GrB_INT32 . select 'int32' :: matrix ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Another way to create an empty matrix is to use the matrix() constructor function: select matrix ( 'int32' ); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) The above matrices are \"unbounced\", they do not have a fixed number of rows and/or columns. The default possible number of rows and columns is defined by the SuiteSparse library to be GrB_INDEX_MAX which is 2^60 power indexes. For the purposes of this documentation this will be referred to as INDEX_MAX and matrices and vector dimensions that are INDEX_MAX in size are reffered to as \"unbounded\". For matrices with known dimensions, the dimensions can be provided in parentesis after the type code. Here a 10 row by 10 column matrix is created: select 'int32(10:10)' :: matrix ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32(10:10) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Another way to make a new matrix is with the matrix constructor function. select matrix ( 'int32' , 8 , 8 ); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32(8:8) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Either dimension can be ommited, this creates a 10 row by unbounded column matrix. select 'int32(10:)' :: matrix ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32(10:) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) This creates a unbounded row by 10 column matrix. select 'int32(:10)' :: matrix ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32(:10) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Note that in all the above cases the matrices created are empty . They contain no stored elements. The memory needed to hold the matrix contains only stored elements, if there isn't a value stored at a given row or column position, no memory is consumed. This is the \"sparse\" in sparse matrix. This is how it's possible to create an unbounded row by unbounded column matrix without exhausting memory trying to allocate 2^120 entries. All graphblas operations are exposed by a series of functions and operators. Here we see three very common operations, returning the number of rows, the number of columns, and the number of store values. select nrows ( 'int32' :: matrix ), ncols ( 'int32' :: matrix ), nvals ( 'int32' :: matrix ); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nrows \u2502 ncols \u2502 nvals \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1152921504606846976 \u2502 1152921504606846976 \u2502 0 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Above you can see the matrix has unbounded rows and columns (the very large number is the number of possible entries). And the number of stored values is zero. These matrices are empty, they contain no elements. Values can be specified after the type(dimension) prefix as an array of elements between square brackets. Empty brackets imply no elements, so empty square brackets are the same as no square brackets as above: select nrows ( 'int32[]' :: matrix ), ncols ( 'int32[]' :: matrix ), nvals ( 'int32[]' :: matrix ); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nrows \u2502 ncols \u2502 nvals \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1152921504606846976 \u2502 1152921504606846976 \u2502 0 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Elements are specified between square brackets are coordinates of 'row_id:column_id:value' separated by spaces: select 'int32[1:2:1 2:3:2 3:1:3]' :: matrix , 'int32(10:)[1:2:1 2:3:2 3:1:3]' :: matrix , 'int32(:10)[1:2:1 2:3:2 3:3:1]' :: matrix ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 matrix \u2502 matrix \u2502 matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32[1:2:1 2:3:2 3:1:3] \u2502 int32(10:)[1:2:1 2:3:2 3:1:3] \u2502 int32(:10)[1:2:1 2:3:2 3:3:1] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Seeing matrices in this format is pretty hard to understand, there are two helpful functions for visualizing matrices, the first is print which prints the matrix in Below you see the number of rows, columns and spaces for a variety of combinations: select print ( 'int32(8:8)[1:2:1 2:3:2 3:1:3]' :: matrix ) as matrix ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 5 6 7 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 1 \u2502 \u2502 2\u2502 2 \u2502 \u2502 3\u2502 3 \u2502 \u2502 4\u2502 \u2502 \u2502 5\u2502 \u2502 \u2502 6\u2502 \u2502 \u2502 7\u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Above you can see the sparse matrix format of an 8x8 matrix. It's only possible to print matrices that have fixed dimensions of a reasonable size. Another useful function is dot_matrix() This turns a matrix into the Graphviz DOT language that is used to draw graph diagrams: select dot_matrix ( 'int32(8:8)[1:2:1 2:3:2 3:1:3]' :: matrix ) as dot_matrix ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 dot_matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 digraph { \u2502 \u2502 1 -> 2 [ label = \"1\" ] \u2502 \u2502 2 -> 3 [ label = \"2\" ] \u2502 \u2502 3 -> 1 [ label = \"3\" ] \u2502 \u2502 } \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 ( 1 row ) Will generate the following diagram: %3 1 1 2 2 1->2 1 3 3 2->3 2 3->1 3 Another useful function is random_matrix() . This will generate a random matrix provided the type, number of rows, number of columns, and the number of (approximate) values and an optional random seed for deterministic generation: select print(random_matrix(8, 8, 16, seed=> 0.42 , max => 42 )) as random_matrix ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 random_matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 5 6 7 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 6 31 \u2502 \u2502 1\u2502 12 26 \u2502 \u2502 2\u2502 \u2502 \u2502 3\u2502 40 11 15 \u2502 \u2502 4\u2502 7 20 12 22 \u2502 \u2502 5\u2502 1 1 \u2502 \u2502 6\u2502 17 \u2502 \u2502 7\u2502 20 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) %3 0 0 3 3 0->3 6 4 4 0->4 31 1 1 3->1 40 7 7 3->7 15 5 5 3->5 11 4->3 20 4->4 12 2 2 4->2 7 6 6 4->6 22 1->4 12 1->7 26 7->2 20 5->0 1 5->6 1 6->3 17","title":"Matrix"},{"location":"test_matrix_header/#test-fixtures","text":"Let's get a test fixture table with a couple matrix and vector columns so that we can do some operations without tediously repeating the literal syntax. These matrices and vectors are construction with random_matrix() show above, and the random_vector() function: select print ( a ) as a , print ( b ) as b , print ( u ) as u , print ( v ) as v from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 b \u2502 u \u2502 v \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 \u2502 0 1 2 3 4 \u2502 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 0\u2502 \u2502 0\u2502 5 \u2502 0\u2502 4 \u2502 \u2502 1\u2502 8 3 \u2502 1\u2502 \u2502 1\u2502 \u2502 1\u2502 1 \u2502 \u2502 2\u2502 2 5 \u2502 2\u2502 5 8 4 \u2502 2\u2502 \u2502 2\u2502 \u2502 \u2502 3\u2502 1 \u2502 3\u2502 4 7 5 \u2502 3\u2502 \u2502 3\u2502 4 \u2502 \u2502 4\u2502 7 5 \u2502 4\u2502 8 \u2502 4\u2502 0 \u2502 4\u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 0 1 2 3 4 \u2502 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 7 4 \u2502 0\u2502 8 \u2502 0\u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 5 \u2502 1\u2502 3 \u2502 1\u2502 0 \u2502 1\u2502 \u2502 \u2502 2\u2502 0 4 10 5 \u2502 2\u2502 4 1 \u2502 2\u2502 3 \u2502 2\u2502 4 \u2502 \u2502 3\u2502 2 1 \u2502 3\u2502 1 5 10 \u2502 3\u2502 2 \u2502 3\u2502 \u2502 \u2502 4\u2502 9 5 \u2502 4\u2502 1 9 1 \u2502 4\u2502 5 \u2502 4\u2502 3 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 0 1 2 3 4 \u2502 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 2 \u2502 0\u2502 10 6 8 6 \u2502 0\u2502 \u2502 0\u2502 5 \u2502 \u2502 1\u2502 2 \u2502 1\u2502 0 8 \u2502 1\u2502 \u2502 1\u2502 \u2502 \u2502 2\u2502 \u2502 2\u2502 \u2502 2\u2502 1 \u2502 2\u2502 3 \u2502 \u2502 3\u2502 5 1 \u2502 3\u2502 \u2502 3\u2502 \u2502 3\u2502 4 \u2502 \u2502 4\u2502 9 \u2502 4\u2502 7 3 \u2502 4\u2502 \u2502 4\u2502 3 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (3 rows)","title":"Test Fixtures"},{"location":"test_matrix_header/#element-wise-operations","text":"The GraphBLAS API has elementwise operations on matrices that operate pairs of matrices. eadd computes the element-wise \u201caddition\u201d of two matrices A and B, element-wise using any binary operator. Elements present on both sides of the operation are included in the result. select print ( a ) as a , binaryop , print ( b ) as b , print ( eadd ( A , B , binaryop )) as union from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 binaryop \u2502 b \u2502 union \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 \u2502 times_int16 \u2502 0 1 2 3 4 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 \u2502 0\u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 8 3 \u2502 \u2502 1\u2502 \u2502 1\u2502 8 3 \u2502 \u2502 2\u2502 2 5 \u2502 \u2502 2\u2502 5 8 4 \u2502 2\u2502 5 2 8 5 4 \u2502 \u2502 3\u2502 1 \u2502 \u2502 3\u2502 4 7 5 \u2502 3\u2502 4 7 5 \u2502 \u2502 4\u2502 7 5 \u2502 \u2502 4\u2502 8 \u2502 4\u2502 7 8 5 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 times_int32 \u2502 0 1 2 3 4 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 7 4 \u2502 \u2502 0\u2502 8 \u2502 0\u2502 0 56 4 \u2502 \u2502 1\u2502 5 \u2502 \u2502 1\u2502 3 \u2502 1\u2502 15 \u2502 \u2502 2\u2502 0 4 10 5 \u2502 \u2502 2\u2502 4 1 \u2502 2\u2502 0 4 10 5 1 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 1 5 10 \u2502 3\u2502 2 1 5 10 \u2502 \u2502 4\u2502 9 5 \u2502 \u2502 4\u2502 1 9 1 \u2502 4\u2502 9 45 1 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 times_int64 \u2502 0 1 2 3 4 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 2 \u2502 \u2502 0\u2502 10 6 8 6 \u2502 0\u2502 10 6 16 6 \u2502 \u2502 1\u2502 2 \u2502 \u2502 1\u2502 0 8 \u2502 1\u2502 2 0 8 \u2502 \u2502 2\u2502 \u2502 \u2502 2\u2502 \u2502 2\u2502 \u2502 \u2502 3\u2502 5 1 \u2502 \u2502 3\u2502 \u2502 3\u2502 5 1 \u2502 \u2502 4\u2502 9 \u2502 \u2502 4\u2502 7 3 \u2502 4\u2502 7 3 9 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (3 rows) emult multiplies elements of two matrices, taking only the intersection of common elements in both matrices, if an element is missing from either the left or right side, it is ommited from the result: select print ( a ) as a , binaryop , print ( b ) as b , print ( emult ( A , B , binaryop )) as intersect from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 binaryop \u2502 b \u2502 intersect \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 \u2502 times_int16 \u2502 0 1 2 3 4 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 \u2502 0\u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 8 3 \u2502 \u2502 1\u2502 \u2502 1\u2502 \u2502 \u2502 2\u2502 2 5 \u2502 \u2502 2\u2502 5 8 4 \u2502 2\u2502 \u2502 \u2502 3\u2502 1 \u2502 \u2502 3\u2502 4 7 5 \u2502 3\u2502 5 \u2502 \u2502 4\u2502 7 5 \u2502 \u2502 4\u2502 8 \u2502 4\u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 times_int32 \u2502 0 1 2 3 4 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 7 4 \u2502 \u2502 0\u2502 8 \u2502 0\u2502 56 \u2502 \u2502 1\u2502 5 \u2502 \u2502 1\u2502 3 \u2502 1\u2502 15 \u2502 \u2502 2\u2502 0 4 10 5 \u2502 \u2502 2\u2502 4 1 \u2502 2\u2502 0 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 1 5 10 \u2502 3\u2502 10 \u2502 \u2502 4\u2502 9 5 \u2502 \u2502 4\u2502 1 9 1 \u2502 4\u2502 9 45 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 times_int64 \u2502 0 1 2 3 4 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 2 \u2502 \u2502 0\u2502 10 6 8 6 \u2502 0\u2502 16 \u2502 \u2502 1\u2502 2 \u2502 \u2502 1\u2502 0 8 \u2502 1\u2502 \u2502 \u2502 2\u2502 \u2502 \u2502 2\u2502 \u2502 2\u2502 \u2502 \u2502 3\u2502 5 1 \u2502 \u2502 3\u2502 \u2502 3\u2502 \u2502 \u2502 4\u2502 9 \u2502 \u2502 4\u2502 7 3 \u2502 4\u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (3 rows) eunion is like eadd but differs in how the binary op is applied. A pair of scalars, alpha and beta define the inputs to the operator when entries are present in one matrix but not the other. select print ( a ) as a , binaryop , print ( b ) as b , print ( eunion ( A , 3 , B , 4 , binaryop )) as union from test_fixture ; ERROR: function eunion(matrix, integer, matrix, integer, binaryop) does not exist LINE 1: ...ect print(a) as a, binaryop, print(b) as b, print(eunion(A, ... ^ HINT: No function matches the given name and argument types. You might need to add explicit type casts. The entire matrix can be reduced to a scalar value: select print ( a ) as a , reduce_scalar ( a , monoid ) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 reduce_scalar \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 \u2502 int32:31 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 0\u2502 \u2502 \u2502 \u2502 1\u2502 8 3 \u2502 \u2502 \u2502 2\u2502 2 5 \u2502 \u2502 \u2502 3\u2502 1 \u2502 \u2502 \u2502 4\u2502 7 5 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 int32:52 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 0\u2502 0 7 4 \u2502 \u2502 \u2502 1\u2502 5 \u2502 \u2502 \u2502 2\u2502 0 4 10 5 \u2502 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 \u2502 4\u2502 9 5 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 int32:19 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 0\u2502 2 \u2502 \u2502 \u2502 1\u2502 2 \u2502 \u2502 \u2502 2\u2502 \u2502 \u2502 \u2502 3\u2502 5 1 \u2502 \u2502 \u2502 4\u2502 9 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (3 rows) The matrix can also be reduced to a column vector: select print ( a ) as a , monoid , print ( reduce_vector ( a , monoid )) as reduce_vector from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 monoid \u2502 reduce_vector \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 \u2502 plus_monoid_int16 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 8 3 \u2502 \u2502 1\u2502 11 \u2502 \u2502 2\u2502 2 5 \u2502 \u2502 2\u2502 7 \u2502 \u2502 3\u2502 1 \u2502 \u2502 3\u2502 1 \u2502 \u2502 4\u2502 7 5 \u2502 \u2502 4\u2502 12 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 plus_monoid_int32 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 7 4 \u2502 \u2502 0\u2502 11 \u2502 \u2502 1\u2502 5 \u2502 \u2502 1\u2502 5 \u2502 \u2502 2\u2502 0 4 10 5 \u2502 \u2502 2\u2502 19 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 3 \u2502 \u2502 4\u2502 9 5 \u2502 \u2502 4\u2502 14 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 plus_monoid_int64 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 2 \u2502 \u2502 0\u2502 2 \u2502 \u2502 1\u2502 2 \u2502 \u2502 1\u2502 2 \u2502 \u2502 2\u2502 \u2502 \u2502 2\u2502 \u2502 \u2502 3\u2502 5 1 \u2502 \u2502 3\u2502 6 \u2502 \u2502 4\u2502 9 \u2502 \u2502 4\u2502 9 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (3 rows) To reduce a row vector, specify that the input should be transposed with the descriptor t0 : select print(a) as a, monoid, print(reduce_vector(a, monoid, descriptor=> 't0' )) as transpose_reduce_vector from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 monoid \u2502 transpose_reduce_vector \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 \u2502 plus_monoid_int16 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 8 3 \u2502 \u2502 1\u2502 2 \u2502 \u2502 2\u2502 2 5 \u2502 \u2502 2\u2502 7 \u2502 \u2502 3\u2502 1 \u2502 \u2502 3\u2502 13 \u2502 \u2502 4\u2502 7 5 \u2502 \u2502 4\u2502 9 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 plus_monoid_int32 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 7 4 \u2502 \u2502 0\u2502 2 \u2502 \u2502 1\u2502 5 \u2502 \u2502 1\u2502 18 \u2502 \u2502 2\u2502 0 4 10 5 \u2502 \u2502 2\u2502 22 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 9 \u2502 \u2502 4\u2502 9 5 \u2502 \u2502 4\u2502 1 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 plus_monoid_int64 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 2 \u2502 \u2502 0\u2502 2 \u2502 \u2502 1\u2502 2 \u2502 \u2502 1\u2502 \u2502 \u2502 2\u2502 \u2502 \u2502 2\u2502 11 \u2502 \u2502 3\u2502 5 1 \u2502 \u2502 3\u2502 5 \u2502 \u2502 4\u2502 9 \u2502 \u2502 4\u2502 1 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (3 rows) Matrix Multiplication (referred to here as A @ B) is the heart of linear algebra. All matrix multiplication happens over a semiring. For the most common form of matrix multiplication, the outer opperation is to multiply coresponding elements with the \"times\" operator and then reduce those products with the \"plus\" operator. This is called the plus_times semiring: select print ( a ) as a , semiring , print ( b ) as b , print ( mxm ( a , b , semiring )) as mxm from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 semiring \u2502 b \u2502 mxm \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 \u2502 plus_times_int16 \u2502 0 1 2 3 4 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 \u2502 0\u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 8 3 \u2502 \u2502 1\u2502 \u2502 1\u2502 32 56 24 40 \u2502 \u2502 2\u2502 2 5 \u2502 \u2502 2\u2502 5 8 4 \u2502 2\u2502 20 35 25 \u2502 \u2502 3\u2502 1 \u2502 \u2502 3\u2502 4 7 5 \u2502 3\u2502 8 \u2502 \u2502 4\u2502 7 5 \u2502 \u2502 4\u2502 8 \u2502 4\u2502 35 56 40 28 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 plus_times_int32 \u2502 0 1 2 3 4 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 7 4 \u2502 \u2502 0\u2502 8 \u2502 0\u2502 28 4 20 47 \u2502 \u2502 1\u2502 5 \u2502 \u2502 1\u2502 3 \u2502 1\u2502 15 \u2502 \u2502 2\u2502 0 4 10 5 \u2502 \u2502 2\u2502 4 1 \u2502 2\u2502 40 17 0 25 60 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 1 5 10 \u2502 3\u2502 1 25 1 \u2502 \u2502 4\u2502 9 5 \u2502 \u2502 4\u2502 1 9 1 \u2502 4\u2502 20 27 5 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 plus_times_int64 \u2502 0 1 2 3 4 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 2 \u2502 \u2502 0\u2502 10 6 8 6 \u2502 0\u2502 \u2502 \u2502 1\u2502 2 \u2502 \u2502 1\u2502 0 8 \u2502 1\u2502 20 12 16 12 \u2502 \u2502 2\u2502 \u2502 \u2502 2\u2502 \u2502 2\u2502 \u2502 \u2502 3\u2502 5 1 \u2502 \u2502 3\u2502 \u2502 3\u2502 7 3 \u2502 \u2502 4\u2502 9 \u2502 \u2502 4\u2502 7 3 \u2502 4\u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (3 rows) AxB can also be done with the @ operator, mimicking the Python syntax. The default semiring for numeric types is plus_times . select print ( a ) as a , '@' as \"@\" , print ( b ) as b , print ( a @ b ) as mxm from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 @ \u2502 b \u2502 mxm \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 \u2502 @ \u2502 0 1 2 3 4 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 \u2502 0\u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 8 3 \u2502 \u2502 1\u2502 \u2502 1\u2502 3 3 4 3 \u2502 \u2502 2\u2502 2 5 \u2502 \u2502 2\u2502 5 8 4 \u2502 2\u2502 3 3 3 \u2502 \u2502 3\u2502 1 \u2502 \u2502 3\u2502 4 7 5 \u2502 3\u2502 4 \u2502 \u2502 4\u2502 7 5 \u2502 \u2502 4\u2502 8 \u2502 4\u2502 2 2 4 2 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 @ \u2502 0 1 2 3 4 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 7 4 \u2502 \u2502 0\u2502 8 \u2502 0\u2502 2 3 3 3 \u2502 \u2502 1\u2502 5 \u2502 \u2502 1\u2502 3 \u2502 1\u2502 1 \u2502 \u2502 2\u2502 0 4 10 5 \u2502 \u2502 2\u2502 4 1 \u2502 2\u2502 2 3 0 3 3 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 1 5 10 \u2502 3\u2502 4 4 4 \u2502 \u2502 4\u2502 9 5 \u2502 \u2502 4\u2502 1 9 1 \u2502 4\u2502 2 1 2 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 @ \u2502 0 1 2 3 4 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 2 \u2502 \u2502 0\u2502 10 6 8 6 \u2502 0\u2502 \u2502 \u2502 1\u2502 2 \u2502 \u2502 1\u2502 0 8 \u2502 1\u2502 0 0 0 0 \u2502 \u2502 2\u2502 \u2502 \u2502 2\u2502 \u2502 2\u2502 \u2502 \u2502 3\u2502 5 1 \u2502 \u2502 3\u2502 \u2502 3\u2502 4 4 \u2502 \u2502 4\u2502 9 \u2502 \u2502 4\u2502 7 3 \u2502 4\u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (3 rows) Matrices can be multipled by vectors on the right taking the linear combination of the matrices columns using the vectors elements as coefficients: select print ( a ), semiring , print ( u ), print ( mxv ( a , u , semiring )) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 print \u2502 semiring \u2502 print \u2502 print \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 \u2502 plus_times_int16 \u2502 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 \u2502 0\u2502 5 \u2502 0\u2502 \u2502 \u2502 1\u2502 8 3 \u2502 \u2502 1\u2502 \u2502 1\u2502 0 \u2502 \u2502 2\u2502 2 5 \u2502 \u2502 2\u2502 \u2502 2\u2502 \u2502 \u2502 3\u2502 1 \u2502 \u2502 3\u2502 \u2502 3\u2502 0 \u2502 \u2502 4\u2502 7 5 \u2502 \u2502 4\u2502 0 \u2502 4\u2502 0 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 plus_times_int32 \u2502 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 7 4 \u2502 \u2502 0\u2502 \u2502 0\u2502 29 \u2502 \u2502 1\u2502 5 \u2502 \u2502 1\u2502 0 \u2502 1\u2502 0 \u2502 \u2502 2\u2502 0 4 10 5 \u2502 \u2502 2\u2502 3 \u2502 2\u2502 40 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 2 \u2502 3\u2502 5 \u2502 \u2502 4\u2502 9 5 \u2502 \u2502 4\u2502 5 \u2502 4\u2502 15 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 plus_times_int64 \u2502 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 2 \u2502 \u2502 0\u2502 \u2502 0\u2502 2 \u2502 \u2502 1\u2502 2 \u2502 \u2502 1\u2502 \u2502 1\u2502 \u2502 \u2502 2\u2502 \u2502 \u2502 2\u2502 1 \u2502 2\u2502 \u2502 \u2502 3\u2502 5 1 \u2502 \u2502 3\u2502 \u2502 3\u2502 \u2502 \u2502 4\u2502 9 \u2502 \u2502 4\u2502 \u2502 4\u2502 9 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (3 rows) 'mxv' is also supported by the @ operator: select print ( a ), '@' , print ( u ), print ( a @ u ) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 print \u2502 ?column? \u2502 print \u2502 print \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 \u2502 @ \u2502 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 \u2502 0\u2502 5 \u2502 0\u2502 \u2502 \u2502 1\u2502 8 3 \u2502 \u2502 1\u2502 \u2502 1\u2502 4 \u2502 \u2502 2\u2502 2 5 \u2502 \u2502 2\u2502 \u2502 2\u2502 \u2502 \u2502 3\u2502 1 \u2502 \u2502 3\u2502 \u2502 3\u2502 4 \u2502 \u2502 4\u2502 7 5 \u2502 \u2502 4\u2502 0 \u2502 4\u2502 4 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 @ \u2502 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 7 4 \u2502 \u2502 0\u2502 \u2502 0\u2502 1 \u2502 \u2502 1\u2502 5 \u2502 \u2502 1\u2502 0 \u2502 1\u2502 1 \u2502 \u2502 2\u2502 0 4 10 5 \u2502 \u2502 2\u2502 3 \u2502 2\u2502 1 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 2 \u2502 3\u2502 4 \u2502 \u2502 4\u2502 9 5 \u2502 \u2502 4\u2502 5 \u2502 4\u2502 1 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 @ \u2502 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 2 \u2502 \u2502 0\u2502 \u2502 0\u2502 2 \u2502 \u2502 1\u2502 2 \u2502 \u2502 1\u2502 \u2502 1\u2502 \u2502 \u2502 2\u2502 \u2502 \u2502 2\u2502 1 \u2502 2\u2502 \u2502 \u2502 3\u2502 5 1 \u2502 \u2502 3\u2502 \u2502 3\u2502 \u2502 \u2502 4\u2502 9 \u2502 \u2502 4\u2502 \u2502 4\u2502 2 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (3 rows) Matrices can be multipled by vectors on the right taking the linear combination of the matrices rows using the vectors elements as coefficients: select print ( v ), semiring , print ( b ), print ( vxm ( v , b , semiring )) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 print \u2502 semiring \u2502 print \u2502 print \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 plus_times_int16 \u2502 0 1 2 3 4 \u2502 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 4 \u2502 \u2502 0\u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 1 \u2502 \u2502 1\u2502 \u2502 1\u2502 16 \u2502 \u2502 2\u2502 \u2502 \u2502 2\u2502 5 8 4 \u2502 2\u2502 28 \u2502 \u2502 3\u2502 4 \u2502 \u2502 3\u2502 4 7 5 \u2502 3\u2502 \u2502 \u2502 4\u2502 \u2502 \u2502 4\u2502 8 \u2502 4\u2502 20 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 plus_times_int32 \u2502 0 1 2 3 4 \u2502 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 \u2502 0\u2502 8 \u2502 0\u2502 16 \u2502 \u2502 1\u2502 \u2502 \u2502 1\u2502 3 \u2502 1\u2502 3 \u2502 \u2502 2\u2502 4 \u2502 \u2502 2\u2502 4 1 \u2502 2\u2502 27 \u2502 \u2502 3\u2502 \u2502 \u2502 3\u2502 1 5 10 \u2502 3\u2502 3 \u2502 \u2502 4\u2502 3 \u2502 \u2502 4\u2502 1 9 1 \u2502 4\u2502 4 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 plus_times_int64 \u2502 0 1 2 3 4 \u2502 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 5 \u2502 \u2502 0\u2502 10 6 8 6 \u2502 0\u2502 71 \u2502 \u2502 1\u2502 \u2502 \u2502 1\u2502 0 8 \u2502 1\u2502 39 \u2502 \u2502 2\u2502 3 \u2502 \u2502 2\u2502 \u2502 2\u2502 40 \u2502 \u2502 3\u2502 4 \u2502 \u2502 3\u2502 \u2502 3\u2502 30 \u2502 \u2502 4\u2502 3 \u2502 \u2502 4\u2502 7 3 \u2502 4\u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (3 rows) 'vxm' is also supported by the @ operator: select print ( v ), '@' , print ( b ), print ( v @ b ) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 print \u2502 ?column? \u2502 print \u2502 print \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 @ \u2502 0 1 2 3 4 \u2502 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 4 \u2502 \u2502 0\u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 1 \u2502 \u2502 1\u2502 \u2502 1\u2502 3 \u2502 \u2502 2\u2502 \u2502 \u2502 2\u2502 5 8 4 \u2502 2\u2502 3 \u2502 \u2502 3\u2502 4 \u2502 \u2502 3\u2502 4 7 5 \u2502 3\u2502 \u2502 \u2502 4\u2502 \u2502 \u2502 4\u2502 8 \u2502 4\u2502 3 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 @ \u2502 0 1 2 3 4 \u2502 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 \u2502 0\u2502 8 \u2502 0\u2502 2 \u2502 \u2502 1\u2502 \u2502 \u2502 1\u2502 3 \u2502 1\u2502 4 \u2502 \u2502 2\u2502 4 \u2502 \u2502 2\u2502 4 1 \u2502 2\u2502 4 \u2502 \u2502 3\u2502 \u2502 \u2502 3\u2502 1 5 10 \u2502 3\u2502 4 \u2502 \u2502 4\u2502 3 \u2502 \u2502 4\u2502 1 9 1 \u2502 4\u2502 2 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 @ \u2502 0 1 2 3 4 \u2502 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 5 \u2502 \u2502 0\u2502 10 6 8 6 \u2502 0\u2502 4 \u2502 \u2502 1\u2502 \u2502 \u2502 1\u2502 0 8 \u2502 1\u2502 4 \u2502 \u2502 2\u2502 3 \u2502 \u2502 2\u2502 \u2502 2\u2502 0 \u2502 \u2502 3\u2502 4 \u2502 \u2502 3\u2502 \u2502 3\u2502 0 \u2502 \u2502 4\u2502 3 \u2502 \u2502 4\u2502 7 3 \u2502 4\u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (3 rows) The selection method calls the GrB_select() API function. The name selection was chosen not to conflict with the SQL keyword select . Selection provides a conditional operator called an indexunaryop and a parameter for the operator to use to compare elements in the matrix. Below, all elements with values greater than 50 are returned: select print ( a ), indexunaryop , print ( selection ( a , indexunaryop , 50 )) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 print \u2502 indexunaryop \u2502 print \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 \u2502 valuegt_int16 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 8 3 \u2502 \u2502 1\u2502 \u2502 \u2502 2\u2502 2 5 \u2502 \u2502 2\u2502 \u2502 \u2502 3\u2502 1 \u2502 \u2502 3\u2502 \u2502 \u2502 4\u2502 7 5 \u2502 \u2502 4\u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 valuegt_int32 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 7 4 \u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 5 \u2502 \u2502 1\u2502 \u2502 \u2502 2\u2502 0 4 10 5 \u2502 \u2502 2\u2502 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 \u2502 \u2502 4\u2502 9 5 \u2502 \u2502 4\u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 valuegt_int64 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 2 \u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 2 \u2502 \u2502 1\u2502 \u2502 \u2502 2\u2502 \u2502 \u2502 2\u2502 \u2502 \u2502 3\u2502 5 1 \u2502 \u2502 3\u2502 \u2502 \u2502 4\u2502 9 \u2502 \u2502 4\u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (3 rows) apply takes an operator of type unaryop and applies it to every element of the matrix. The 'ainv_int32' returned the additive inverse (the negative value for integers) of every element: select print ( a ), unaryop , print ( apply ( a , unaryop )) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 print \u2502 unaryop \u2502 print \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 \u2502 ainv_int16 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 8 3 \u2502 \u2502 1\u2502 -8 -3 \u2502 \u2502 2\u2502 2 5 \u2502 \u2502 2\u2502 -2 -5 \u2502 \u2502 3\u2502 1 \u2502 \u2502 3\u2502 -1 \u2502 \u2502 4\u2502 7 5 \u2502 \u2502 4\u2502 -7 -5 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 ainv_int32 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 7 4 \u2502 \u2502 0\u2502 0 -7 -4 \u2502 \u2502 1\u2502 5 \u2502 \u2502 1\u2502 -5 \u2502 \u2502 2\u2502 0 4 10 5 \u2502 \u2502 2\u2502 0 -4-10 -5 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 -2 -1 \u2502 \u2502 4\u2502 9 5 \u2502 \u2502 4\u2502 -9 -5 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 ainv_int64 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 2 \u2502 \u2502 0\u2502 -2 \u2502 \u2502 1\u2502 2 \u2502 \u2502 1\u2502 -2 \u2502 \u2502 2\u2502 \u2502 \u2502 2\u2502 \u2502 \u2502 3\u2502 5 1 \u2502 \u2502 3\u2502 -5 -1 \u2502 \u2502 4\u2502 9 \u2502 \u2502 4\u2502 -9 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (3 rows) Elements can be set individually with set_element , the modified input is returned: select print ( set_element ( a , 4 , 4 , 4 )) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 print \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 8 3 \u2502 \u2502 2\u2502 2 5 \u2502 \u2502 3\u2502 1 \u2502 \u2502 4\u2502 7 4 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 7 4 \u2502 \u2502 1\u2502 5 \u2502 \u2502 2\u2502 0 4 10 5 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 4\u2502 9 5 4 \u2502 \u2502 \u2502 \u2502 0 1 2 3 4 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 2 \u2502 \u2502 1\u2502 2 \u2502 \u2502 2\u2502 \u2502 \u2502 3\u2502 5 1 \u2502 \u2502 4\u2502 9 4 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (3 rows) Scalar elements can be extracted individually with get_element select get_element ( a , 3 , 3 ) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 get_element \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int \u2502 \u2502 int \u2502 \u2502 int32:5 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (3 rows) The print function returns a descripton of the matrix from SuiteSparse. select info ( a ) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 info \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 \u2502 5x5 GraphBLAS int32_t matrix, bitmap by row \u2502 \u2502 A-> matrix , 7 entries , memory : 357 bytes \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 5 x5 GraphBLAS int32_t matrix , bitmap by row \u2502 \u2502 A-> matrix , 12 entries , memory : 357 bytes \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 5 x5 GraphBLAS int32_t matrix , bitmap by row \u2502 \u2502 A-> matrix , 5 entries , memory : 357 bytes \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 ( 3 rows ) The print function takes an optional \"level\" argument that defaults to 1 which is a short summary. select info ( a , 5 ) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 info \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 \u2502 5x5 GraphBLAS int32_t matrix, bitmap by row \u2502 \u2502 A-> matrix , 7 entries , memory : 357 bytes \u2502 \u2502 \u2502 \u2502 ( 1 , 3 ) 8 \u2502 \u2502 ( 1 , 4 ) 3 \u2502 \u2502 ( 2 , 1 ) 2 \u2502 \u2502 ( 2 , 3 ) 5 \u2502 \u2502 ( 3 , 4 ) 1 \u2502 \u2502 ( 4 , 2 ) 7 \u2502 \u2502 ( 4 , 4 ) 5 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 5 x5 GraphBLAS int32_t matrix , bitmap by row \u2502 \u2502 A-> matrix , 12 entries , memory : 357 bytes \u2502 \u2502 \u2502 \u2502 ( 0 , 1 ) 0 \u2502 \u2502 ( 0 , 2 ) 7 \u2502 \u2502 ( 0 , 3 ) 4 \u2502 \u2502 ( 1 , 1 ) 5 \u2502 \u2502 ( 2 , 0 ) 0 \u2502 \u2502 ( 2 , 1 ) 4 \u2502 \u2502 ( 2 , 2 ) 10 \u2502 \u2502 ( 2 , 3 ) 5 \u2502 \u2502 ( 3 , 0 ) 2 \u2502 \u2502 ( 3 , 4 ) 1 \u2502 \u2502 ( 4 , 1 ) 9 \u2502 \u2502 ( 4 , 2 ) 5 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 5 x5 GraphBLAS int32_t matrix , bitmap by row \u2502 \u2502 A-> matrix , 5 entries , memory : 357 bytes \u2502 \u2502 \u2502 \u2502 ( 0 , 2 ) 2 \u2502 \u2502 ( 1 , 0 ) 2 \u2502 \u2502 ( 3 , 3 ) 5 \u2502 \u2502 ( 3 , 4 ) 1 \u2502 \u2502 ( 4 , 2 ) 9 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 ( 3 rows ) The dup function duplicates a matrix returning a new matrix object with the same values: select dup ( a ) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 dup \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32(5:5)[1:3:8 1:4:3 2:1:2 2:3:5 3:4:1 4:2:7 4:4:5] \u2502 \u2502 int32(5:5)[0:1:0 0:2:7 0:3:4 1:1:5 2:0:0 2:1:4 2:2:10 2:3:5 3:0:2 3:4:1 4:1:9 4:2:5] \u2502 \u2502 int32(5:5)[0:2:2 1:0:2 3:3:5 3:4:1 4:2:9] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (3 rows) The wait method is used to \"complete\" a matrix, which may have pending operations waiting to be performed when using the default SuiteSparse non-blocking mode. As a side effect, wait will sort the elements of the input: select wait ( 'int32[2:2:2 3:3:3 1:1:1]' :: matrix ); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 wait \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32[1:1:1 2:2:2 3:3:3] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) The clear function clears the matrix of all elements and returns the same object, but empty. The dimensions do not change: select clear ( 'int32[1:1:1 2:2:2 3:3:3]' :: matrix ); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 clear \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row)","title":"Element-wise operations"},{"location":"test_matrix_header/#extra-tests","text":"This documentation also forms the basis for the onesparse tests, These tests run the documentation against a live server, all the above results are automatically generated. select nrows ( 'int32(10)[1:1:1 2:2:2 3:3:3]' :: matrix ); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nrows \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 10 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select ncols('int32(10)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 ncols \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1152921504606846976 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nvals('int32(10)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nvals \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 3 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nrows('int32(10:)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nrows \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 10 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select ncols('int32(10:)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 ncols \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1152921504606846976 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nvals('int32(10:)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nvals \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 3 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nrows('int32(:10)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nrows \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1152921504606846976 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select ncols('int32(:10)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 ncols \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 10 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nvals('int32(:10)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nvals \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 3 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nrows('int32(10:10)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nrows \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 10 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select ncols('int32(10:10)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 ncols \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 10 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nvals('int32(10:10)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nvals \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 3 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row)","title":"Extra tests"},{"location":"test_scalar_header/","text":"Scalar This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING' ; create extension if not exists onesparse; Describe the scalar type List of data types Schema | Name | Internal name | Size | Elements | Owner | Access privileges | Description -----------+--------+---------------+------+----------+----------+-------------------+------------- onesparse | scalar | scalar | var | | postgres | | ( 1 row ) print a scalar select print ( 'int32:42' :: scalar ); print ------- 42 (1 row) print a scalar select print ( 'int32:42' :: scalar , 5 ); ERROR: function print(scalar, integer) does not exist LINE 1: select print('int32:42'::scalar, 5); ^ HINT: No function matches the given name and argument types. You might need to add explicit type casts. Duplicate a scalar select dup ( 'int32:42' :: scalar ); dup ---------- int32:42 (1 row) Wait for a scalar to complete in non-blocking mode select wait ( 'int32:42' :: scalar ); wait ---------- int32:42 (1 row) Clear a scalar, deleting its stored element. select clear ( 'int32:42' :: scalar ); clear ------- int (1 row)","title":"Scalar"},{"location":"test_scalar_header/#scalar","text":"This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING' ; create extension if not exists onesparse; Describe the scalar type List of data types Schema | Name | Internal name | Size | Elements | Owner | Access privileges | Description -----------+--------+---------------+------+----------+----------+-------------------+------------- onesparse | scalar | scalar | var | | postgres | | ( 1 row ) print a scalar select print ( 'int32:42' :: scalar ); print ------- 42 (1 row) print a scalar select print ( 'int32:42' :: scalar , 5 ); ERROR: function print(scalar, integer) does not exist LINE 1: select print('int32:42'::scalar, 5); ^ HINT: No function matches the given name and argument types. You might need to add explicit type casts. Duplicate a scalar select dup ( 'int32:42' :: scalar ); dup ---------- int32:42 (1 row) Wait for a scalar to complete in non-blocking mode select wait ( 'int32:42' :: scalar ); wait ---------- int32:42 (1 row) Clear a scalar, deleting its stored element. select clear ( 'int32:42' :: scalar ); clear ------- int (1 row)","title":"Scalar"},{"location":"test_scalar_op_f4/","text":"Scalar float4 Operations Test various scalar math operations with native Postgres types select ( 1 :: float4 ) :: scalar + - 1 :: float4 ; ?column? --------------- fp32:0.000000 (1 row) select 1::float4 + (-1::float4)::scalar; ?column? ---------- 0 (1 row) select (1::float4)::scalar - 1::float4; ?column? --------------- fp32:0.000000 (1 row) select 1::float4 - (1::float4)::scalar; ?column? ---------- 0 (1 row) select (1::float4)::scalar * -1::float4; ?column? ---------------- fp32:-1.000000 (1 row) select 1::float4 * (-1::float4)::scalar; ?column? ---------- -1 (1 row) select (1::float4)::scalar / 1::float4; ?column? --------------- fp32:1.000000 (1 row) select 1::float4 / (1::float4)::scalar; ?column? ---------- 1 (1 row) Test construction of min, zero and max values: select '-1' :: float4 :: scalar ; scalar ---------------- fp32:-1.000000 (1 row) select '0'::float4::scalar; scalar --------------- fp32:0.000000 (1 row) select '1'::float4::scalar; scalar --------------- fp32:1.000000 (1 row) Test setting a scalar value from max to 2 select set ( '1' :: float4 :: scalar , 2 ); set --------------- fp32:2.000000 (1 row) Test various casting functions used by the CREATE CAST machinery: select scalar_float4 (( - 1 ) :: float4 ); scalar_float4 ---------------- fp32:-1.000000 (1 row) select scalar_float4((0)::float4); scalar_float4 --------------- fp32:0.000000 (1 row) select scalar_float4((1)::float4); scalar_float4 --------------- fp32:1.000000 (1 row) select float4_scalar((-1)::float4::scalar); float4_scalar --------------- -1 (1 row) select float4_scalar((0)::float4::scalar); float4_scalar --------------- 0 (1 row) select float4_scalar((1)::float4::scalar); float4_scalar --------------- 1 (1 row) These casting functions cast the Postgres type float4 to the GraphBLAS scalar type GrB_INT32 . select cast ( - 1 :: float4 as scalar ); scalar ---------------- fp32:-1.000000 (1 row) select cast(0::float4 as scalar); scalar --------------- fp32:0.000000 (1 row) select cast(1::float4 as scalar); scalar --------------- fp32:1.000000 (1 row) These tests cast back from the scalar type GrB_INT32 to the Postgres type float4 select cast (( - 1 :: float4 ) :: scalar as float4 ); float4 -------- -1 (1 row) select cast((0::float4)::scalar as float4); float4 -------- 0 (1 row) select cast((1::float4)::scalar as scalar); scalar --------------- fp32:1.000000 (1 row)","title":"Scalar float4 Operations"},{"location":"test_scalar_op_f4/#scalar-float4-operations","text":"Test various scalar math operations with native Postgres types select ( 1 :: float4 ) :: scalar + - 1 :: float4 ; ?column? --------------- fp32:0.000000 (1 row) select 1::float4 + (-1::float4)::scalar; ?column? ---------- 0 (1 row) select (1::float4)::scalar - 1::float4; ?column? --------------- fp32:0.000000 (1 row) select 1::float4 - (1::float4)::scalar; ?column? ---------- 0 (1 row) select (1::float4)::scalar * -1::float4; ?column? ---------------- fp32:-1.000000 (1 row) select 1::float4 * (-1::float4)::scalar; ?column? ---------- -1 (1 row) select (1::float4)::scalar / 1::float4; ?column? --------------- fp32:1.000000 (1 row) select 1::float4 / (1::float4)::scalar; ?column? ---------- 1 (1 row) Test construction of min, zero and max values: select '-1' :: float4 :: scalar ; scalar ---------------- fp32:-1.000000 (1 row) select '0'::float4::scalar; scalar --------------- fp32:0.000000 (1 row) select '1'::float4::scalar; scalar --------------- fp32:1.000000 (1 row) Test setting a scalar value from max to 2 select set ( '1' :: float4 :: scalar , 2 ); set --------------- fp32:2.000000 (1 row) Test various casting functions used by the CREATE CAST machinery: select scalar_float4 (( - 1 ) :: float4 ); scalar_float4 ---------------- fp32:-1.000000 (1 row) select scalar_float4((0)::float4); scalar_float4 --------------- fp32:0.000000 (1 row) select scalar_float4((1)::float4); scalar_float4 --------------- fp32:1.000000 (1 row) select float4_scalar((-1)::float4::scalar); float4_scalar --------------- -1 (1 row) select float4_scalar((0)::float4::scalar); float4_scalar --------------- 0 (1 row) select float4_scalar((1)::float4::scalar); float4_scalar --------------- 1 (1 row) These casting functions cast the Postgres type float4 to the GraphBLAS scalar type GrB_INT32 . select cast ( - 1 :: float4 as scalar ); scalar ---------------- fp32:-1.000000 (1 row) select cast(0::float4 as scalar); scalar --------------- fp32:0.000000 (1 row) select cast(1::float4 as scalar); scalar --------------- fp32:1.000000 (1 row) These tests cast back from the scalar type GrB_INT32 to the Postgres type float4 select cast (( - 1 :: float4 ) :: scalar as float4 ); float4 -------- -1 (1 row) select cast((0::float4)::scalar as float4); float4 -------- 0 (1 row) select cast((1::float4)::scalar as scalar); scalar --------------- fp32:1.000000 (1 row)","title":"Scalar float4 Operations"},{"location":"test_scalar_op_f8/","text":"Scalar float8 Operations Test various scalar math operations with native Postgres types select ( 1 :: float8 ) :: scalar + - 1 :: float8 ; ?column? --------------- fp64:0.000000 (1 row) select 1::float8 + (-1::float8)::scalar; ?column? ---------- 0 (1 row) select (1::float8)::scalar - 1::float8; ?column? --------------- fp64:0.000000 (1 row) select 1::float8 - (1::float8)::scalar; ?column? ---------- 0 (1 row) select (1::float8)::scalar * -1::float8; ?column? ---------------- fp64:-1.000000 (1 row) select 1::float8 * (-1::float8)::scalar; ?column? ---------- -1 (1 row) select (1::float8)::scalar / 1::float8; ?column? --------------- fp64:1.000000 (1 row) select 1::float8 / (1::float8)::scalar; ?column? ---------- 1 (1 row) Test construction of min, zero and max values: select '-1' :: float8 :: scalar ; scalar ---------------- fp64:-1.000000 (1 row) select '0'::float8::scalar; scalar --------------- fp64:0.000000 (1 row) select '1'::float8::scalar; scalar --------------- fp64:1.000000 (1 row) Test setting a scalar value from max to 2 select set ( '1' :: float8 :: scalar , 2 ); set --------------- fp64:2.000000 (1 row) Test various casting functions used by the CREATE CAST machinery: select scalar_float8 (( - 1 ) :: float8 ); scalar_float8 ---------------- fp64:-1.000000 (1 row) select scalar_float8((0)::float8); scalar_float8 --------------- fp64:0.000000 (1 row) select scalar_float8((1)::float8); scalar_float8 --------------- fp64:1.000000 (1 row) select float8_scalar((-1)::float8::scalar); float8_scalar --------------- -1 (1 row) select float8_scalar((0)::float8::scalar); float8_scalar --------------- 0 (1 row) select float8_scalar((1)::float8::scalar); float8_scalar --------------- 1 (1 row) These casting functions cast the Postgres type float8 to the GraphBLAS scalar type GrB_INT64 . select cast ( - 1 :: float8 as scalar ); scalar ---------------- fp64:-1.000000 (1 row) select cast(0::float8 as scalar); scalar --------------- fp64:0.000000 (1 row) select cast(1::float8 as scalar); scalar --------------- fp64:1.000000 (1 row) These tests cast back from the scalar type GrB_INT64 to the Postgres type float8 select cast (( - 1 :: float8 ) :: scalar as float8 ); float8 -------- -1 (1 row) select cast((0::float8)::scalar as float8); float8 -------- 0 (1 row) select cast((1::float8)::scalar as scalar); scalar --------------- fp64:1.000000 (1 row)","title":"Scalar float8 Operations"},{"location":"test_scalar_op_f8/#scalar-float8-operations","text":"Test various scalar math operations with native Postgres types select ( 1 :: float8 ) :: scalar + - 1 :: float8 ; ?column? --------------- fp64:0.000000 (1 row) select 1::float8 + (-1::float8)::scalar; ?column? ---------- 0 (1 row) select (1::float8)::scalar - 1::float8; ?column? --------------- fp64:0.000000 (1 row) select 1::float8 - (1::float8)::scalar; ?column? ---------- 0 (1 row) select (1::float8)::scalar * -1::float8; ?column? ---------------- fp64:-1.000000 (1 row) select 1::float8 * (-1::float8)::scalar; ?column? ---------- -1 (1 row) select (1::float8)::scalar / 1::float8; ?column? --------------- fp64:1.000000 (1 row) select 1::float8 / (1::float8)::scalar; ?column? ---------- 1 (1 row) Test construction of min, zero and max values: select '-1' :: float8 :: scalar ; scalar ---------------- fp64:-1.000000 (1 row) select '0'::float8::scalar; scalar --------------- fp64:0.000000 (1 row) select '1'::float8::scalar; scalar --------------- fp64:1.000000 (1 row) Test setting a scalar value from max to 2 select set ( '1' :: float8 :: scalar , 2 ); set --------------- fp64:2.000000 (1 row) Test various casting functions used by the CREATE CAST machinery: select scalar_float8 (( - 1 ) :: float8 ); scalar_float8 ---------------- fp64:-1.000000 (1 row) select scalar_float8((0)::float8); scalar_float8 --------------- fp64:0.000000 (1 row) select scalar_float8((1)::float8); scalar_float8 --------------- fp64:1.000000 (1 row) select float8_scalar((-1)::float8::scalar); float8_scalar --------------- -1 (1 row) select float8_scalar((0)::float8::scalar); float8_scalar --------------- 0 (1 row) select float8_scalar((1)::float8::scalar); float8_scalar --------------- 1 (1 row) These casting functions cast the Postgres type float8 to the GraphBLAS scalar type GrB_INT64 . select cast ( - 1 :: float8 as scalar ); scalar ---------------- fp64:-1.000000 (1 row) select cast(0::float8 as scalar); scalar --------------- fp64:0.000000 (1 row) select cast(1::float8 as scalar); scalar --------------- fp64:1.000000 (1 row) These tests cast back from the scalar type GrB_INT64 to the Postgres type float8 select cast (( - 1 :: float8 ) :: scalar as float8 ); float8 -------- -1 (1 row) select cast((0::float8)::scalar as float8); float8 -------- 0 (1 row) select cast((1::float8)::scalar as scalar); scalar --------------- fp64:1.000000 (1 row)","title":"Scalar float8 Operations"},{"location":"test_scalar_op_i2/","text":"Scalar smallint Operations Test various scalar math operations with native Postgres types select ( 1 :: smallint ) :: scalar + - 1 :: smallint ; ?column? ---------- int16:0 (1 row) select 1::smallint + (-1::smallint)::scalar; ?column? ---------- 0 (1 row) select (1::smallint)::scalar - 1::smallint; ?column? ---------- int16:0 (1 row) select 1::smallint - (1::smallint)::scalar; ?column? ---------- 0 (1 row) select (1::smallint)::scalar * -1::smallint; ?column? ---------- int16:-1 (1 row) select 1::smallint * (-1::smallint)::scalar; ?column? ---------- -1 (1 row) select (1::smallint)::scalar / 1::smallint; ?column? ---------- int16:1 (1 row) select 1::smallint / (1::smallint)::scalar; ?column? ---------- 1 (1 row) Test construction of min, zero and max values: select '-1' :: smallint :: scalar ; scalar ---------- int16:-1 (1 row) select '0'::smallint::scalar; scalar --------- int16:0 (1 row) select '1'::smallint::scalar; scalar --------- int16:1 (1 row) Test setting a scalar value from max to 2 select set ( '1' :: smallint :: scalar , 2 ); set --------- int16:2 (1 row) Test various casting functions used by the CREATE CAST machinery: select scalar_smallint (( - 1 ) :: smallint ); scalar_smallint ----------------- int16:-1 (1 row) select scalar_smallint((0)::smallint); scalar_smallint ----------------- int16:0 (1 row) select scalar_smallint((1)::smallint); scalar_smallint ----------------- int16:1 (1 row) select smallint_scalar((-1)::smallint::scalar); smallint_scalar ----------------- -1 (1 row) select smallint_scalar((0)::smallint::scalar); smallint_scalar ----------------- 0 (1 row) select smallint_scalar((1)::smallint::scalar); smallint_scalar ----------------- 1 (1 row) These casting functions cast the Postgres type smallint to the GraphBLAS scalar type GrB_INT16 . select cast ( - 1 :: smallint as scalar ); scalar ---------- int16:-1 (1 row) select cast(0::smallint as scalar); scalar --------- int16:0 (1 row) select cast(1::smallint as scalar); scalar --------- int16:1 (1 row) These tests cast back from the scalar type GrB_INT16 to the Postgres type smallint select cast (( - 1 :: smallint ) :: scalar as smallint ); int2 ------ -1 (1 row) select cast((0::smallint)::scalar as smallint); int2 ------ 0 (1 row) select cast((1::smallint)::scalar as scalar); scalar --------- int16:1 (1 row)","title":"Scalar smallint Operations"},{"location":"test_scalar_op_i2/#scalar-smallint-operations","text":"Test various scalar math operations with native Postgres types select ( 1 :: smallint ) :: scalar + - 1 :: smallint ; ?column? ---------- int16:0 (1 row) select 1::smallint + (-1::smallint)::scalar; ?column? ---------- 0 (1 row) select (1::smallint)::scalar - 1::smallint; ?column? ---------- int16:0 (1 row) select 1::smallint - (1::smallint)::scalar; ?column? ---------- 0 (1 row) select (1::smallint)::scalar * -1::smallint; ?column? ---------- int16:-1 (1 row) select 1::smallint * (-1::smallint)::scalar; ?column? ---------- -1 (1 row) select (1::smallint)::scalar / 1::smallint; ?column? ---------- int16:1 (1 row) select 1::smallint / (1::smallint)::scalar; ?column? ---------- 1 (1 row) Test construction of min, zero and max values: select '-1' :: smallint :: scalar ; scalar ---------- int16:-1 (1 row) select '0'::smallint::scalar; scalar --------- int16:0 (1 row) select '1'::smallint::scalar; scalar --------- int16:1 (1 row) Test setting a scalar value from max to 2 select set ( '1' :: smallint :: scalar , 2 ); set --------- int16:2 (1 row) Test various casting functions used by the CREATE CAST machinery: select scalar_smallint (( - 1 ) :: smallint ); scalar_smallint ----------------- int16:-1 (1 row) select scalar_smallint((0)::smallint); scalar_smallint ----------------- int16:0 (1 row) select scalar_smallint((1)::smallint); scalar_smallint ----------------- int16:1 (1 row) select smallint_scalar((-1)::smallint::scalar); smallint_scalar ----------------- -1 (1 row) select smallint_scalar((0)::smallint::scalar); smallint_scalar ----------------- 0 (1 row) select smallint_scalar((1)::smallint::scalar); smallint_scalar ----------------- 1 (1 row) These casting functions cast the Postgres type smallint to the GraphBLAS scalar type GrB_INT16 . select cast ( - 1 :: smallint as scalar ); scalar ---------- int16:-1 (1 row) select cast(0::smallint as scalar); scalar --------- int16:0 (1 row) select cast(1::smallint as scalar); scalar --------- int16:1 (1 row) These tests cast back from the scalar type GrB_INT16 to the Postgres type smallint select cast (( - 1 :: smallint ) :: scalar as smallint ); int2 ------ -1 (1 row) select cast((0::smallint)::scalar as smallint); int2 ------ 0 (1 row) select cast((1::smallint)::scalar as scalar); scalar --------- int16:1 (1 row)","title":"Scalar smallint Operations"},{"location":"test_scalar_op_i4/","text":"Scalar integer Operations Test various scalar math operations with native Postgres types select ( 1 :: integer ) :: scalar + - 1 :: integer ; ?column? ---------- int32:0 (1 row) select 1::integer + (-1::integer)::scalar; ?column? ---------- 0 (1 row) select (1::integer)::scalar - 1::integer; ?column? ---------- int32:0 (1 row) select 1::integer - (1::integer)::scalar; ?column? ---------- 0 (1 row) select (1::integer)::scalar * -1::integer; ?column? ---------- int32:-1 (1 row) select 1::integer * (-1::integer)::scalar; ?column? ---------- -1 (1 row) select (1::integer)::scalar / 1::integer; ?column? ---------- int32:1 (1 row) select 1::integer / (1::integer)::scalar; ?column? ---------- 1 (1 row) Test construction of min, zero and max values: select '-1' :: integer :: scalar ; scalar ---------- int32:-1 (1 row) select '0'::integer::scalar; scalar --------- int32:0 (1 row) select '1'::integer::scalar; scalar --------- int32:1 (1 row) Test setting a scalar value from max to 2 select set ( '1' :: integer :: scalar , 2 ); set --------- int32:2 (1 row) Test various casting functions used by the CREATE CAST machinery: select scalar_integer (( - 1 ) :: integer ); scalar_integer ---------------- int32:-1 (1 row) select scalar_integer((0)::integer); scalar_integer ---------------- int32:0 (1 row) select scalar_integer((1)::integer); scalar_integer ---------------- int32:1 (1 row) select integer_scalar((-1)::integer::scalar); integer_scalar ---------------- -1 (1 row) select integer_scalar((0)::integer::scalar); integer_scalar ---------------- 0 (1 row) select integer_scalar((1)::integer::scalar); integer_scalar ---------------- 1 (1 row) These casting functions cast the Postgres type integer to the GraphBLAS scalar type GrB_INT32 . select cast ( - 1 :: integer as scalar ); scalar ---------- int32:-1 (1 row) select cast(0::integer as scalar); scalar --------- int32:0 (1 row) select cast(1::integer as scalar); scalar --------- int32:1 (1 row) These tests cast back from the scalar type GrB_INT32 to the Postgres type integer select cast (( - 1 :: integer ) :: scalar as integer ); int4 ------ -1 (1 row) select cast((0::integer)::scalar as integer); int4 ------ 0 (1 row) select cast((1::integer)::scalar as scalar); scalar --------- int32:1 (1 row)","title":"Scalar integer Operations"},{"location":"test_scalar_op_i4/#scalar-integer-operations","text":"Test various scalar math operations with native Postgres types select ( 1 :: integer ) :: scalar + - 1 :: integer ; ?column? ---------- int32:0 (1 row) select 1::integer + (-1::integer)::scalar; ?column? ---------- 0 (1 row) select (1::integer)::scalar - 1::integer; ?column? ---------- int32:0 (1 row) select 1::integer - (1::integer)::scalar; ?column? ---------- 0 (1 row) select (1::integer)::scalar * -1::integer; ?column? ---------- int32:-1 (1 row) select 1::integer * (-1::integer)::scalar; ?column? ---------- -1 (1 row) select (1::integer)::scalar / 1::integer; ?column? ---------- int32:1 (1 row) select 1::integer / (1::integer)::scalar; ?column? ---------- 1 (1 row) Test construction of min, zero and max values: select '-1' :: integer :: scalar ; scalar ---------- int32:-1 (1 row) select '0'::integer::scalar; scalar --------- int32:0 (1 row) select '1'::integer::scalar; scalar --------- int32:1 (1 row) Test setting a scalar value from max to 2 select set ( '1' :: integer :: scalar , 2 ); set --------- int32:2 (1 row) Test various casting functions used by the CREATE CAST machinery: select scalar_integer (( - 1 ) :: integer ); scalar_integer ---------------- int32:-1 (1 row) select scalar_integer((0)::integer); scalar_integer ---------------- int32:0 (1 row) select scalar_integer((1)::integer); scalar_integer ---------------- int32:1 (1 row) select integer_scalar((-1)::integer::scalar); integer_scalar ---------------- -1 (1 row) select integer_scalar((0)::integer::scalar); integer_scalar ---------------- 0 (1 row) select integer_scalar((1)::integer::scalar); integer_scalar ---------------- 1 (1 row) These casting functions cast the Postgres type integer to the GraphBLAS scalar type GrB_INT32 . select cast ( - 1 :: integer as scalar ); scalar ---------- int32:-1 (1 row) select cast(0::integer as scalar); scalar --------- int32:0 (1 row) select cast(1::integer as scalar); scalar --------- int32:1 (1 row) These tests cast back from the scalar type GrB_INT32 to the Postgres type integer select cast (( - 1 :: integer ) :: scalar as integer ); int4 ------ -1 (1 row) select cast((0::integer)::scalar as integer); int4 ------ 0 (1 row) select cast((1::integer)::scalar as scalar); scalar --------- int32:1 (1 row)","title":"Scalar integer Operations"},{"location":"test_scalar_op_i8/","text":"Scalar bigint Operations Test various scalar math operations with native Postgres types select ( 1 :: bigint ) :: scalar + - 1 :: bigint ; ?column? ---------- int64:0 (1 row) select 1::bigint + (-1::bigint)::scalar; ?column? ---------- 0 (1 row) select (1::bigint)::scalar - 1::bigint; ?column? ---------- int64:0 (1 row) select 1::bigint - (1::bigint)::scalar; ?column? ---------- 0 (1 row) select (1::bigint)::scalar * -1::bigint; ?column? ---------- int64:-1 (1 row) select 1::bigint * (-1::bigint)::scalar; ?column? ---------- -1 (1 row) select (1::bigint)::scalar / 1::bigint; ?column? ---------- int64:1 (1 row) select 1::bigint / (1::bigint)::scalar; ?column? ---------- 1 (1 row) Test construction of min, zero and max values: select '-1' :: bigint :: scalar ; scalar ---------- int64:-1 (1 row) select '0'::bigint::scalar; scalar --------- int64:0 (1 row) select '1'::bigint::scalar; scalar --------- int64:1 (1 row) Test setting a scalar value from max to 2 select set ( '1' :: bigint :: scalar , 2 ); set --------- int64:2 (1 row) Test various casting functions used by the CREATE CAST machinery: select scalar_bigint (( - 1 ) :: bigint ); scalar_bigint --------------- int64:-1 (1 row) select scalar_bigint((0)::bigint); scalar_bigint --------------- int64:0 (1 row) select scalar_bigint((1)::bigint); scalar_bigint --------------- int64:1 (1 row) select bigint_scalar((-1)::bigint::scalar); bigint_scalar --------------- -1 (1 row) select bigint_scalar((0)::bigint::scalar); bigint_scalar --------------- 0 (1 row) select bigint_scalar((1)::bigint::scalar); bigint_scalar --------------- 1 (1 row) These casting functions cast the Postgres type bigint to the GraphBLAS scalar type GrB_INT64 . select cast ( - 1 :: bigint as scalar ); scalar ---------- int64:-1 (1 row) select cast(0::bigint as scalar); scalar --------- int64:0 (1 row) select cast(1::bigint as scalar); scalar --------- int64:1 (1 row) These tests cast back from the scalar type GrB_INT64 to the Postgres type bigint select cast (( - 1 :: bigint ) :: scalar as bigint ); int8 ------ -1 (1 row) select cast((0::bigint)::scalar as bigint); int8 ------ 0 (1 row) select cast((1::bigint)::scalar as scalar); scalar --------- int64:1 (1 row)","title":"Scalar bigint Operations"},{"location":"test_scalar_op_i8/#scalar-bigint-operations","text":"Test various scalar math operations with native Postgres types select ( 1 :: bigint ) :: scalar + - 1 :: bigint ; ?column? ---------- int64:0 (1 row) select 1::bigint + (-1::bigint)::scalar; ?column? ---------- 0 (1 row) select (1::bigint)::scalar - 1::bigint; ?column? ---------- int64:0 (1 row) select 1::bigint - (1::bigint)::scalar; ?column? ---------- 0 (1 row) select (1::bigint)::scalar * -1::bigint; ?column? ---------- int64:-1 (1 row) select 1::bigint * (-1::bigint)::scalar; ?column? ---------- -1 (1 row) select (1::bigint)::scalar / 1::bigint; ?column? ---------- int64:1 (1 row) select 1::bigint / (1::bigint)::scalar; ?column? ---------- 1 (1 row) Test construction of min, zero and max values: select '-1' :: bigint :: scalar ; scalar ---------- int64:-1 (1 row) select '0'::bigint::scalar; scalar --------- int64:0 (1 row) select '1'::bigint::scalar; scalar --------- int64:1 (1 row) Test setting a scalar value from max to 2 select set ( '1' :: bigint :: scalar , 2 ); set --------- int64:2 (1 row) Test various casting functions used by the CREATE CAST machinery: select scalar_bigint (( - 1 ) :: bigint ); scalar_bigint --------------- int64:-1 (1 row) select scalar_bigint((0)::bigint); scalar_bigint --------------- int64:0 (1 row) select scalar_bigint((1)::bigint); scalar_bigint --------------- int64:1 (1 row) select bigint_scalar((-1)::bigint::scalar); bigint_scalar --------------- -1 (1 row) select bigint_scalar((0)::bigint::scalar); bigint_scalar --------------- 0 (1 row) select bigint_scalar((1)::bigint::scalar); bigint_scalar --------------- 1 (1 row) These casting functions cast the Postgres type bigint to the GraphBLAS scalar type GrB_INT64 . select cast ( - 1 :: bigint as scalar ); scalar ---------- int64:-1 (1 row) select cast(0::bigint as scalar); scalar --------- int64:0 (1 row) select cast(1::bigint as scalar); scalar --------- int64:1 (1 row) These tests cast back from the scalar type GrB_INT64 to the Postgres type bigint select cast (( - 1 :: bigint ) :: scalar as bigint ); int8 ------ -1 (1 row) select cast((0::bigint)::scalar as bigint); int8 ------ 0 (1 row) select cast((1::bigint)::scalar as scalar); scalar --------- int64:1 (1 row)","title":"Scalar bigint Operations"},{"location":"test_vector_header/","text":"Vectors This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING' ; create extension if not exists onesparse; Describe the vector type: List of data types Schema | Name | Internal name | Size | Elements | Owner | Access privileges | Description -----------+--------+---------------+------+----------+----------+-------------------+------------- onesparse | vector | vector | var | | postgres | | ( 1 row ) An empty vector can be constructed many ways, but one of the simplest is casting a type code to the matrix type. In this case int32 means GrB_INT32. The type codes are intentionally compressed to be as short as possible for smaller pg_dumps. Much of these functions are basically vector versions of the same functions for matrix. See those docs for details: select 'int32' :: vector ; vector -------- int32 (1 row) select nvals('int32'::vector); nvals ------- 0 (1 row) select size('int32'::vector); size --------------------- 1152921504606846976 (1 row) select 'int32[]'::vector; vector -------- int32 (1 row) select nvals('int32[]'::vector); nvals ------- 0 (1 row) select size('int32[]'::vector); size --------------------- 1152921504606846976 (1 row) select 'int32(10)'::vector; vector ----------- int32(10) (1 row) select nvals('int32(10)'::vector); nvals ------- 0 (1 row) select size('int32(10)'::vector); size ------ 10 (1 row) select 'int32(10)[]'::vector; vector ----------- int32(10) (1 row) select nvals('int32(10)[]'::vector); nvals ------- 0 (1 row) select size('int32(10)[]'::vector); size ------ 10 (1 row) select 'int32[0:1 1:2 2:3]'::vector; vector -------------------- int32[0:1 1:2 2:3] (1 row) select nvals('int32[0:1 1:2 2:3]'::vector); nvals ------- 3 (1 row) select 'int32(10)[0:1 1:2 2:3]'::vector; vector ------------------------ int32(10)[0:1 1:2 2:3] (1 row) select size('int32(10)[0:1 1:2 2:3]'::vector); size ------ 10 (1 row) select size('int32(2)[0:1 1:2 2:3]'::vector); ERROR: INVALID_INDEX GraphBLAS error: GrB_INVALID_INDEX function: GrB_Vector_setElement_INT64 (w, x, row) Row index 2 out of range; must be < 2: Error setting Vector Element LINE 1: select size('int32(2)[0:1 1:2 2:3]'::vector); ^ select ewise_add('int32[0:1 1:2 2:3]'::vector, 'int32[0:1 1:2 2:3]'::vector, 'plus_int32'); ERROR: function ewise_add(vector, vector, unknown) does not exist LINE 1: select ewise_add('int32[0:1 1:2 2:3]'::vector, 'int32[0:1 1:... ^ HINT: No function matches the given name and argument types. You might need to add explicit type casts. select ewise_mult('int32[0:1 1:2 2:3]'::vector, 'int32[0:1 1:2 2:3]'::vector, 'times_int32'); ERROR: function ewise_mult(vector, vector, unknown) does not exist LINE 1: select ewise_mult('int32[0:1 1:2 2:3]'::vector, 'int32[0:1 1... ^ HINT: No function matches the given name and argument types. You might need to add explicit type casts. select ewise_union('int32[0:1 1:2 2:3]'::vector, 42, 'int32[0:1 1:2 2:3]'::vector, 84, 'plus_int32'); ERROR: function ewise_union(vector, integer, vector, integer, unknown) does not exist LINE 1: select ewise_union('int32[0:1 1:2 2:3]'::vector, 42, 'int32[... ^ HINT: No function matches the given name and argument types. You might need to add explicit type casts. select reduce_scalar('int32[0:1 1:2 2:3]'::vector, 'plus_monoid_int32'); reduce_scalar --------------- int32:6 (1 row) select selection('int32[0:1 1:2 2:3]'::vector, 'valuegt_int32', 1); selection ---------------- int32[1:2 2:3] (1 row) select apply('int32[1:1 2:2 3:3]'::vector, 'ainv_int32'::unaryop); apply ----------------------- int32[1:-1 2:-2 3:-3] (1 row) Elements can be set individually with set_element , the modified input is returned: select set_element ( 'int32[1:1 2:2 3:3]' :: vector , 4 , 4 ); set_element ------------------------ int32[1:1 2:2 3:3 4:4] (1 row) Scalar elements can be extracted individually with get_element select get_element ( 'int32[1:1 2:2 3:3]' :: vector , 3 ); get_element ------------- int32:3 (1 row) select print('int32[1:1 2:2 3:3]'::vector); ERROR: integer out of range CONTEXT: PL/pgSQL function print(vector) line 3 during statement block local variable initialization select print('int32[1:1 2:2 3:3]'::vector, 5); ERROR: function print(vector, integer) does not exist LINE 1: select print('int32[1:1 2:2 3:3]'::vector, 5); ^ HINT: No function matches the given name and argument types. You might need to add explicit type casts. select wait('int32[0:1 1:2 2:3]'::vector); wait ------ (1 row) select dup('int32[0:1 1:2 2:3]'::vector); dup -------------------- int32[0:1 1:2 2:3] (1 row) select clear('int32[0:1 1:2 2:3]'::vector); clear ------- (1 row)","title":"Vectors"},{"location":"test_vector_header/#vectors","text":"This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING' ; create extension if not exists onesparse; Describe the vector type: List of data types Schema | Name | Internal name | Size | Elements | Owner | Access privileges | Description -----------+--------+---------------+------+----------+----------+-------------------+------------- onesparse | vector | vector | var | | postgres | | ( 1 row ) An empty vector can be constructed many ways, but one of the simplest is casting a type code to the matrix type. In this case int32 means GrB_INT32. The type codes are intentionally compressed to be as short as possible for smaller pg_dumps. Much of these functions are basically vector versions of the same functions for matrix. See those docs for details: select 'int32' :: vector ; vector -------- int32 (1 row) select nvals('int32'::vector); nvals ------- 0 (1 row) select size('int32'::vector); size --------------------- 1152921504606846976 (1 row) select 'int32[]'::vector; vector -------- int32 (1 row) select nvals('int32[]'::vector); nvals ------- 0 (1 row) select size('int32[]'::vector); size --------------------- 1152921504606846976 (1 row) select 'int32(10)'::vector; vector ----------- int32(10) (1 row) select nvals('int32(10)'::vector); nvals ------- 0 (1 row) select size('int32(10)'::vector); size ------ 10 (1 row) select 'int32(10)[]'::vector; vector ----------- int32(10) (1 row) select nvals('int32(10)[]'::vector); nvals ------- 0 (1 row) select size('int32(10)[]'::vector); size ------ 10 (1 row) select 'int32[0:1 1:2 2:3]'::vector; vector -------------------- int32[0:1 1:2 2:3] (1 row) select nvals('int32[0:1 1:2 2:3]'::vector); nvals ------- 3 (1 row) select 'int32(10)[0:1 1:2 2:3]'::vector; vector ------------------------ int32(10)[0:1 1:2 2:3] (1 row) select size('int32(10)[0:1 1:2 2:3]'::vector); size ------ 10 (1 row) select size('int32(2)[0:1 1:2 2:3]'::vector); ERROR: INVALID_INDEX GraphBLAS error: GrB_INVALID_INDEX function: GrB_Vector_setElement_INT64 (w, x, row) Row index 2 out of range; must be < 2: Error setting Vector Element LINE 1: select size('int32(2)[0:1 1:2 2:3]'::vector); ^ select ewise_add('int32[0:1 1:2 2:3]'::vector, 'int32[0:1 1:2 2:3]'::vector, 'plus_int32'); ERROR: function ewise_add(vector, vector, unknown) does not exist LINE 1: select ewise_add('int32[0:1 1:2 2:3]'::vector, 'int32[0:1 1:... ^ HINT: No function matches the given name and argument types. You might need to add explicit type casts. select ewise_mult('int32[0:1 1:2 2:3]'::vector, 'int32[0:1 1:2 2:3]'::vector, 'times_int32'); ERROR: function ewise_mult(vector, vector, unknown) does not exist LINE 1: select ewise_mult('int32[0:1 1:2 2:3]'::vector, 'int32[0:1 1... ^ HINT: No function matches the given name and argument types. You might need to add explicit type casts. select ewise_union('int32[0:1 1:2 2:3]'::vector, 42, 'int32[0:1 1:2 2:3]'::vector, 84, 'plus_int32'); ERROR: function ewise_union(vector, integer, vector, integer, unknown) does not exist LINE 1: select ewise_union('int32[0:1 1:2 2:3]'::vector, 42, 'int32[... ^ HINT: No function matches the given name and argument types. You might need to add explicit type casts. select reduce_scalar('int32[0:1 1:2 2:3]'::vector, 'plus_monoid_int32'); reduce_scalar --------------- int32:6 (1 row) select selection('int32[0:1 1:2 2:3]'::vector, 'valuegt_int32', 1); selection ---------------- int32[1:2 2:3] (1 row) select apply('int32[1:1 2:2 3:3]'::vector, 'ainv_int32'::unaryop); apply ----------------------- int32[1:-1 2:-2 3:-3] (1 row) Elements can be set individually with set_element , the modified input is returned: select set_element ( 'int32[1:1 2:2 3:3]' :: vector , 4 , 4 ); set_element ------------------------ int32[1:1 2:2 3:3 4:4] (1 row) Scalar elements can be extracted individually with get_element select get_element ( 'int32[1:1 2:2 3:3]' :: vector , 3 ); get_element ------------- int32:3 (1 row) select print('int32[1:1 2:2 3:3]'::vector); ERROR: integer out of range CONTEXT: PL/pgSQL function print(vector) line 3 during statement block local variable initialization select print('int32[1:1 2:2 3:3]'::vector, 5); ERROR: function print(vector, integer) does not exist LINE 1: select print('int32[1:1 2:2 3:3]'::vector, 5); ^ HINT: No function matches the given name and argument types. You might need to add explicit type casts. select wait('int32[0:1 1:2 2:3]'::vector); wait ------ (1 row) select dup('int32[0:1 1:2 2:3]'::vector); dup -------------------- int32[0:1 1:2 2:3] (1 row) select clear('int32[0:1 1:2 2:3]'::vector); clear ------- (1 row)","title":"Vectors"}]}