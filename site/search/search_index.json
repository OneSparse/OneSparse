{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to OneSparse Postgres OneSparse is a Postgres extension that bind the powerful SuiteSparse:GraphBLAS Linear Algebra library, exposing it's functionality and new types, functions and operators in Postgres. Join us in the OneSparse Discussions Board and say hi!. TLDR; Docker Demo Start the onesparse demo docker container, substitute suitable password and container name: docker run -d -e POSTGRES_PASSWORD=password -it --name onesparse-demo-container onesparse/onesparse:0.1.0 The container will start detached in the background, verify it's running with 'docker ps'. Now exec a psql process to interact with the container: $ docker exec -u postgres -it onesparse-demo-container psql psql (17.0 (Debian 17.0-1.pgdg120+1)) Type \"help\" for help. postgres=# select 'i4'::matrix; matrix -------- i4[] (1 row) postgres=# See the Documentation for some examples for creating matrices and vectors. You can verify the doctests with docker using: $ docker exec -u postgres -it onesparse-demo-container make installcheck Summary OneSparse Postgres extends the PostgreSQL object relational database with the state-of-the-art SuiteSparse:GraphBLAS high performance dense/sparse linear algebra library. SuiteSparse contains thousands of algorithms optimizing tasks for algebraic graph traversal, machine learning, AI, science, and engineering. SuiteSparse's powerful built-in JIT compiler can target multiple hardware architectures, including GPUs, with no changes to your code. Join us in the OneSparse Discussions Board and say hi!. Like the JSON/JSONB types did for unstructured data, OneSparse makes dense and sparse matrices and vectors fully native Postgres types. OneSparse supports optimized, parallel matrix multiplication and other operations like reduction, selection, assignment, extraction, elementwise union, and intersection. These methods can be used for both traditional numeric algebraic computing, or sparse graph analytics over adjacency and incidence matrices. Like numpy and scipy did for Python, OneSparse transforms Postgres into a powerful framework for linear algebra and its infinite industry application: mathematics, engineering, economics, machine learning, bioinformatics and graph science. Matrix multiplication is as simple as 'A @ B', just as in Python. Leverage SQL for it's power of filtering, viewing and aggregating, and use linear algebra for its power of abstract reasoning, numeric analytical power, and parallel graph analytics. GraphBLAS is a sparse linear algebra API optimized for processing dense and sparse matrices and in particular graphs encoded as sparse matrices and vectors. In addition to common real/integer matrix algebra operations \"plus\" and \"times\", GraphBLAS supports many different \"semiring\" algebra operations, that can be used as basic building blocks to implement a wide variety of algebraic and graph solutions. OneSparse Postgres aims to unify the three algebraic paradigms of relational, procedural, and algebraic style approaches. In the image below, all three visualization are presenting the same information: the tabular form shows rows a relational indicating edge relationships, the graphical form shows the procedural approach, and the sparse matrix form shows the algebraic approach. The diagram below shows the three paradigms of sparse graph computation, relational, procedural and algebraic. Each approach contains the exact same information, each edge is represented as an element of a table, graph, or matrix. With OneSparse, programmers can choose which approach best fits their needs, and move seamlessly between them: The algebraic approach offers a powerful abstraction over the underlying compute architecture used to do the actual work. Using SuiteSparse's powerful built-in JIT compiler, any hardware architecture can be targeted with no code changes to the algorithm. This cannot be said for the common procedural approach taken by most graph libraries and frameworks. OneSparse's goal is to enable and encourage the multi-architecture future, where the right hardware is used for the right phase of any particularly complex algorithm or data pipeine. By abstracting away the specific and highly optimzation sensitive hardware details, problem solvers can focus on the problems, and allow hardware specialists to optimize for any given architecture: Why Linear Algebra? OneSparse brings the power of Linear Algebra to Postgres. In languages like Python, similar roles are fulfilled with packages like numpy and scipy. OneSparse goes beyond dense matrix multiplication and is highly optimized not only for dense and sparse matrices, but also optimizes for an unlimited number of powerful and and useful algebras by supporting JIT compilation of both built-in and user defined Semirings . Semirings can be thought of as an abstraction of the \"additive\" and \"multiplicative\" operations typically used in Matrix Multiplication . They are particularly useful when implementing graph algorithms across an adjacency matrix: For example, to compute the shortest path between rows and columns of a sparse matrix, instead of multiplying elements they are added, and instead of adding to reduce to the final value, the minimum is taken. This form of Tropical Algebra is a very powerful mathematical technique used in solving optimization and other minimization and maximization problems. Another exotic form of Semiring is the Log Semiring which is a powerful tool for traversing graphs whose edges represent probabilities by leveraging Log probability algebra for speed and better numeric stability. Other GraphBLAS Semirings are used to optimize algebraic operations to minimize data movement. For example, the \"any_pair\" semiring is used instead of \"plus_times\" in many Breadth-First Search Algorithms to avoid any mathematical operations and unnecessary data movement Instead of adding results, \"any\" value is used, thus allowing the JIT compiler to optimize as it sees fit. Instead of loading element values and multiplying them, the \"pair\" operator is used to simply proceed only if both edges in a multiplication are present, without ever loading or multiplying their values. OneSparse leverages the expertise in the field of sparse matrix programming by The GraphBLAS Forum and uses the SuiteSparse:GraphBLAS API implementation. SuiteSparse:GraphBLAS is brought to us by the work of Dr. Tim Davis , professor in the Department of Computer Science and Engineering at Texas A&M University. News and information can provide you with a lot more background information, in addition to the references below. TODO Test harness matrix for all supported pg versions A few missing ops, concat/split/kron Large Object support up to 4TB subscripting syntax support add type[] array casting to vectors and matrices add type[] operators for extract, containment, etc. add type[] constructors and tuple iterators select ops: A < 42 lookup semirings with base name and object \"lookup('any_pair', A)\" for type specific semiring semiring functions? \"plus_times(A, B)\" Wrap LAGraph Zero-copy into python-graphblas objects in plpythonu psycopg2 packed binary adapters to python-graphblas","title":"Welcome to OneSparse Postgres"},{"location":"#welcome-to-onesparse-postgres","text":"OneSparse is a Postgres extension that bind the powerful SuiteSparse:GraphBLAS Linear Algebra library, exposing it's functionality and new types, functions and operators in Postgres. Join us in the OneSparse Discussions Board and say hi!.","title":"Welcome to OneSparse Postgres"},{"location":"#tldr-docker-demo","text":"Start the onesparse demo docker container, substitute suitable password and container name: docker run -d -e POSTGRES_PASSWORD=password -it --name onesparse-demo-container onesparse/onesparse:0.1.0 The container will start detached in the background, verify it's running with 'docker ps'. Now exec a psql process to interact with the container: $ docker exec -u postgres -it onesparse-demo-container psql psql (17.0 (Debian 17.0-1.pgdg120+1)) Type \"help\" for help. postgres=# select 'i4'::matrix; matrix -------- i4[] (1 row) postgres=# See the Documentation for some examples for creating matrices and vectors. You can verify the doctests with docker using: $ docker exec -u postgres -it onesparse-demo-container make installcheck","title":"TLDR; Docker Demo"},{"location":"#summary","text":"OneSparse Postgres extends the PostgreSQL object relational database with the state-of-the-art SuiteSparse:GraphBLAS high performance dense/sparse linear algebra library. SuiteSparse contains thousands of algorithms optimizing tasks for algebraic graph traversal, machine learning, AI, science, and engineering. SuiteSparse's powerful built-in JIT compiler can target multiple hardware architectures, including GPUs, with no changes to your code. Join us in the OneSparse Discussions Board and say hi!. Like the JSON/JSONB types did for unstructured data, OneSparse makes dense and sparse matrices and vectors fully native Postgres types. OneSparse supports optimized, parallel matrix multiplication and other operations like reduction, selection, assignment, extraction, elementwise union, and intersection. These methods can be used for both traditional numeric algebraic computing, or sparse graph analytics over adjacency and incidence matrices. Like numpy and scipy did for Python, OneSparse transforms Postgres into a powerful framework for linear algebra and its infinite industry application: mathematics, engineering, economics, machine learning, bioinformatics and graph science. Matrix multiplication is as simple as 'A @ B', just as in Python. Leverage SQL for it's power of filtering, viewing and aggregating, and use linear algebra for its power of abstract reasoning, numeric analytical power, and parallel graph analytics. GraphBLAS is a sparse linear algebra API optimized for processing dense and sparse matrices and in particular graphs encoded as sparse matrices and vectors. In addition to common real/integer matrix algebra operations \"plus\" and \"times\", GraphBLAS supports many different \"semiring\" algebra operations, that can be used as basic building blocks to implement a wide variety of algebraic and graph solutions. OneSparse Postgres aims to unify the three algebraic paradigms of relational, procedural, and algebraic style approaches. In the image below, all three visualization are presenting the same information: the tabular form shows rows a relational indicating edge relationships, the graphical form shows the procedural approach, and the sparse matrix form shows the algebraic approach. The diagram below shows the three paradigms of sparse graph computation, relational, procedural and algebraic. Each approach contains the exact same information, each edge is represented as an element of a table, graph, or matrix. With OneSparse, programmers can choose which approach best fits their needs, and move seamlessly between them: The algebraic approach offers a powerful abstraction over the underlying compute architecture used to do the actual work. Using SuiteSparse's powerful built-in JIT compiler, any hardware architecture can be targeted with no code changes to the algorithm. This cannot be said for the common procedural approach taken by most graph libraries and frameworks. OneSparse's goal is to enable and encourage the multi-architecture future, where the right hardware is used for the right phase of any particularly complex algorithm or data pipeine. By abstracting away the specific and highly optimzation sensitive hardware details, problem solvers can focus on the problems, and allow hardware specialists to optimize for any given architecture:","title":"Summary"},{"location":"#why-linear-algebra","text":"OneSparse brings the power of Linear Algebra to Postgres. In languages like Python, similar roles are fulfilled with packages like numpy and scipy. OneSparse goes beyond dense matrix multiplication and is highly optimized not only for dense and sparse matrices, but also optimizes for an unlimited number of powerful and and useful algebras by supporting JIT compilation of both built-in and user defined Semirings . Semirings can be thought of as an abstraction of the \"additive\" and \"multiplicative\" operations typically used in Matrix Multiplication . They are particularly useful when implementing graph algorithms across an adjacency matrix: For example, to compute the shortest path between rows and columns of a sparse matrix, instead of multiplying elements they are added, and instead of adding to reduce to the final value, the minimum is taken. This form of Tropical Algebra is a very powerful mathematical technique used in solving optimization and other minimization and maximization problems. Another exotic form of Semiring is the Log Semiring which is a powerful tool for traversing graphs whose edges represent probabilities by leveraging Log probability algebra for speed and better numeric stability. Other GraphBLAS Semirings are used to optimize algebraic operations to minimize data movement. For example, the \"any_pair\" semiring is used instead of \"plus_times\" in many Breadth-First Search Algorithms to avoid any mathematical operations and unnecessary data movement Instead of adding results, \"any\" value is used, thus allowing the JIT compiler to optimize as it sees fit. Instead of loading element values and multiplying them, the \"pair\" operator is used to simply proceed only if both edges in a multiplication are present, without ever loading or multiplying their values. OneSparse leverages the expertise in the field of sparse matrix programming by The GraphBLAS Forum and uses the SuiteSparse:GraphBLAS API implementation. SuiteSparse:GraphBLAS is brought to us by the work of Dr. Tim Davis , professor in the Department of Computer Science and Engineering at Texas A&M University. News and information can provide you with a lot more background information, in addition to the references below.","title":"Why Linear Algebra?"},{"location":"#todo","text":"Test harness matrix for all supported pg versions A few missing ops, concat/split/kron Large Object support up to 4TB subscripting syntax support add type[] array casting to vectors and matrices add type[] operators for extract, containment, etc. add type[] constructors and tuple iterators select ops: A < 42 lookup semirings with base name and object \"lookup('any_pair', A)\" for type specific semiring semiring functions? \"plus_times(A, B)\" Wrap LAGraph Zero-copy into python-graphblas objects in plpythonu psycopg2 packed binary adapters to python-graphblas","title":"TODO"},{"location":"test_matrix_header/","text":"Matrix Documentation This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure the extension is installed. create extension if not exists onesparse ; OneSparse wraps the SuiteSparse:GraphBLAS library and extends Postgres by adding new types and functions that allow you to do sparse and dense linear algebra in Postgres. This is similar to functionality packages like numpy and scipy.sparse bring to Python. The most powerful object in OneSparse is a Matrix. A Matrix is a two dimensional array of data with a certain number of rows m and columns n . Typically matrices are very memory hungry data structures, requiring m * n memory to hold all of the elements. This limits traditional matrix libraries, because many problems in linear algebra are sparse . Not every element is used in the problem or even definable. Traditional linear algebra libraries usually encode sparse matrices into dense matrices by using the number zero to indicate \"nothing\", but this does not aleviate the memory problem. For matrices with a large number of rows and columns this means vast areas of memories filled with zeros that end up being multiplied away, wasting energy. OneSparse matrices however are smart, and can adapt to the number of actually useful elements in a Matrix. They can be dense or sparse, the SuiteSparse library will adapt to choose the right backend format. Matrices and Graphs Every matrix is a graph, whether you think of it that way or not. And every graph has a corresponding matrix. The data that you put into tables can also describe a graph, and thus a matrix. These three different ways of thinking about tables, graphs, and matrices is one of the core concepts of OneSparse: While SuiteSparse is optimized for processing sparse matrices and vectors, it also supports optimized kernels for dense objects. A dense matrix is just a sparse matrix with all its elements. In this case SuiteSparse will automatically store it in a dense optimal format and use CPUs or GPUs appropriately to process them. If the matrix has bounds, it can be printed to the console if they are reasonable size, this is useful for debugging and experimentation: select print ( 'int32(4:4)' :: matrix ); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 print \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 \u2502 \u2502 2\u2502 \u2502 \u2502 3\u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Note that this matrix is empty, it's not filled with \"zeros\", it contains no elements . The memory needed to hold the matrix contains only stored elements, if there isn't a value stored at a given row or column position, no memory is consumed. This is the \"sparse\" in sparse matrix. This is how it's possible to create an unbounded row by unbounded column matrix without exhausting memory trying to allocate 2^120 entries. Drawing Matrices and Vectors The draw() function turns a matrix into the Graphviz DOT language that is used to draw graph diagrams: select draw ( 'int32(4:4)[1:2:1 2:3:2 3:1:3]' :: matrix ) as draw ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 draw \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 digraph { \u2502 \u2502 1 -> 2 [ label = \"1\" ] \u2502 \u2502 2 -> 3 [ label = \"2\" ] \u2502 \u2502 3 -> 1 [ label = \"3\" ] \u2502 \u2502 } \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 ( 1 row ) Will generate the following diagram: %3 1 1 2 2 1->2 1 3 3 2->3 2 3->1 3 Let's look at our cast of test objects for the remaining examples. These objects from the onesparse.test_fixture table. select * from test_fixture ; \u250c\u2500[ RECORD 1 ]\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 t \u2502 int32 \u2502 \u2502 a \u2502 int32(4:4)[0:2:0 0:3:3 1:0:2 1:2:1 1:3:0 2:0:2 2:1:2 3:0:2 3:2:1] \u2502 \u2502 b \u2502 int32(4:4)[0:3:4 1:2:3 1:3:1 2:1:2 2:3:4 3:1:0 3:2:2] \u2502 \u2502 d \u2502 int32(4:4)[0:0:1 0:1:1 0:2:1 0:3:1 1:0:1 1:1:1 1:2:1 1:3:1 2:0:1 2:1:1 2:2:1 2:3:1 3:0:1 3:1:1 3:2:1 3:3:1] \u2502 \u2502 s \u2502 int32(2:2)[0:0:1 0:1:1 1:1:1] \u2502 \u2502 u \u2502 int32(4)[1:2] \u2502 \u2502 v \u2502 int32(4)[2:3] \u2502 \u2502 unaryop \u2502 ainv_int32 \u2502 \u2502 indexunaryop \u2502 valuegt_int32 \u2502 \u2502 binaryop \u2502 times_int32 \u2502 \u2502 monoid \u2502 plus_monoid_int32 \u2502 \u2502 semiring \u2502 plus_times_int32 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Here are a couple of sparse matrices from the test_fixture table. We'll call them a and b in these docs: select print ( a ) as a , print ( b ) as b from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 b \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 0 1 2 3 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 3 \u2502 0\u2502 4 \u2502 \u2502 1\u2502 2 1 0 \u2502 1\u2502 3 1 \u2502 \u2502 2\u2502 2 2 \u2502 2\u2502 2 4 \u2502 \u2502 3\u2502 2 1 \u2502 3\u2502 0 2 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) %3 0 0 2 2 0->2 0 3 3 0->3 3 2->0 2 1 1 2->1 2 3->0 2 3->2 1 1->0 2 1->2 1 1->3 0 %3 0 0 3 3 0->3 4 1 1 3->1 0 2 2 3->2 2 1->3 1 1->2 3 2->3 4 2->1 2 Here are some sparse test vectors, they will be used for some of the examples below: select print ( u ) as u , print ( v ) as v from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 u \u2502 v \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 2 \u2502 1\u2502 \u2502 \u2502 2\u2502 \u2502 2\u2502 3 \u2502 \u2502 3\u2502 \u2502 3\u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) vector cluster_vector node0 node1 1:2 node2 node3 vector cluster_vector node0 node1 node2 2:3 node3 There is also an example \"dense\" matrix named 'd': select print ( d ) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 print \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 1 1 1 1 \u2502 \u2502 1\u2502 1 1 1 1 \u2502 \u2502 2\u2502 1 1 1 1 \u2502 \u2502 3\u2502 1 1 1 1 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) One way of thinking about a \"dense\" matrix is a fully connected graph, these can be constructed with the dense_matrix() function: %3 0 0 0->0 1 1 1 0->1 1 2 2 0->2 1 3 3 0->3 1 1->0 1 1->1 1 1->2 1 1->3 1 2->0 1 2->1 1 2->2 1 2->3 1 3->0 1 3->1 1 3->2 1 3->3 1 And another matrix named 's' which is a Sierpinsky Graph, which we'll show off a bit later. select print ( s ) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 print \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 1 1 \u2502 \u2502 1\u2502 1 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) The matrix data type wraps a SuiteSparse GrB_Matrix handle and delegates functions from SQL to the library through instances of this type. Empty Matrices An empty matrix can be constructed many ways, but one of the simplest is casting a type code to the matrix type. In this case int32 means the SuiteSparse type GrB_INT32 . select 'int32' :: matrix ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Another way to create an empty matrix is to use the matrix() constructor function: select matrix ( 'int32' ); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Matrix dimensions The above matrices are \"unbounded\", they do not have a fixed number of rows and/or columns. The default possible number of rows and columns is defined by the SuiteSparse library to be GrB_INDEX_MAX which is 2^60 power indexes. For the purposes of this documentation this will be referred to as INDEX_MAX and matrices and vector dimensions that are INDEX_MAX in size are reffered to as \"unbounded\". For matrices with known dimensions, the dimensions can be provided in parentesis after the type code. Here a 4 row by 4 column matrix is created: select 'int32(4:4)' :: matrix ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32(4:4) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Another way to make a new matrix is with the matrix constructor function. select matrix ( 'int32' , 4 , 4 ); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32(4:4) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Either dimension can be ommited, this creates a 4 row by unbounded column matrix. select 'int32(4:)' :: matrix ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32(4:) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) This creates a unbounded row by 4 column matrix. select 'int32(:4)' :: matrix ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32(:4) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) All graphblas operations are exposed by a series of functions and operators. Here we see three very common operations, returning the number of rows, the number of columns, and the number of store values. select nrows ( 'int32' :: matrix ), ncols ( 'int32' :: matrix ), nvals ( 'int32' :: matrix ); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nrows \u2502 ncols \u2502 nvals \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1152921504606846976 \u2502 1152921504606846976 \u2502 0 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Above you can see the matrix has unbounded rows and columns (the very large number is the number of possible entries). And the number of stored values is zero. These matrices are empty, they contain no elements. Values can be specified after the type(dimension) prefix as an array of elements between square brackets. Empty brackets imply no elements, so empty square brackets are the same as no square brackets as above: select nrows ( 'int32[]' :: matrix ), ncols ( 'int32[]' :: matrix ), nvals ( 'int32[]' :: matrix ); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nrows \u2502 ncols \u2502 nvals \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1152921504606846976 \u2502 1152921504606846976 \u2502 0 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Elements are specified between square brackets are coordinates of 'row_id:column_id:value' separated by spaces: select 'int32[1:2:1 2:3:2 3:1:3]' :: matrix , 'int32(4:)[1:2:1 2:3:2 3:1:3]' :: matrix , 'int32(:4)[1:2:1 2:3:2 3:3:1]' :: matrix ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 matrix \u2502 matrix \u2502 matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32[1:2:1 2:3:2 3:1:3] \u2502 int32(4:)[1:2:1 2:3:2 3:1:3] \u2502 int32(:4)[1:2:1 2:3:2 3:3:1] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Elements All the elements in a matrix can be iterated with the elements() function: select * from elements (( select a from test_fixture )); \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 i \u2502 j \u2502 v \u2502 \u251c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 \u2502 2 \u2502 int32:0 \u2502 \u2502 0 \u2502 3 \u2502 int32:3 \u2502 \u2502 1 \u2502 0 \u2502 int32:2 \u2502 \u2502 1 \u2502 2 \u2502 int32:1 \u2502 \u2502 1 \u2502 3 \u2502 int32:0 \u2502 \u2502 2 \u2502 0 \u2502 int32:2 \u2502 \u2502 2 \u2502 1 \u2502 int32:2 \u2502 \u2502 3 \u2502 0 \u2502 int32:2 \u2502 \u2502 3 \u2502 2 \u2502 int32:1 \u2502 \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (9 rows) The inverse operation of constructing matrices from rows can be done with matrix_agg() : select matrix_agg ( i , i , i ) as unbound_matrix from generate_series ( 0 , 10 ) as i ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 unbound_matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32[0:0:0 1:1:1 2:2:2 3:3:3 4:4:4 5:5:5 6:6:6 7:7:7 8:8:8 9:9:9 10:10:10] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Aggregate matrices are always unbounded so use resize() to bound the matrix: select print ( resize ( matrix_agg ( i , i , i ), 10 , 10 )) as bound_matrix from generate_series ( 0 , 10 ) as i ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 bound_matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 5 6 7 8 9 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 \u2502 \u2502 1\u2502 1 \u2502 \u2502 2\u2502 2 \u2502 \u2502 3\u2502 3 \u2502 \u2502 4\u2502 4 \u2502 \u2502 5\u2502 5 \u2502 \u2502 6\u2502 6 \u2502 \u2502 7\u2502 7 \u2502 \u2502 8\u2502 8 \u2502 \u2502 9\u2502 9 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Elements can be set individually with set_element , the modified input is returned: select print ( set_element ( a , 1 , 1 , 1 )) as set_element from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 set_element \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 3 \u2502 \u2502 1\u2502 2 1 1 0 \u2502 \u2502 2\u2502 2 2 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Scalar elements can be extracted individually with get_element select get_element ( a , 3 , 2 ) as get_element from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 get_element \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32:1 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) If an element does exist get_element will return an \"empty\" scalar: select get_element ( a , 3 , 3 ) as get_element from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 get_element \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Random Matrices random_matrix will generate a random matrix provided the type, number of rows, number of columns, and the number of (approximate) values, an optional max value, and an optional random seed for deterministic generation: select print(random_matrix(8, 8, 16, seed=> 0.42 , max => 42 )) as random_matrix ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 random_matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 5 6 7 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 6 31 \u2502 \u2502 1\u2502 12 \u2502 \u2502 2\u2502 26 \u2502 \u2502 3\u2502 40 \u2502 \u2502 4\u2502 11 15 7 \u2502 \u2502 5\u2502 20 12 22 1 \u2502 \u2502 6\u2502 1 \u2502 \u2502 7\u2502 17 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) This random matrix is also a random graph : %3 0 0 4 4 0->4 6 5 5 0->5 31 1 1 4->1 11 3 3 4->3 15 7 7 4->7 7 5->0 20 5->1 12 6 6 5->6 1 5->3 22 1->6 12 6->4 1 2 2 2->1 26 3->5 40 7->2 17 Elementwise Addition The GraphBLAS API has elementwise operations on matrices that operate pairs of matrices. eadd computes the element-wise \u201caddition\u201d of two matrices a and b, element-wise using any binary operator. Elements present on both sides of the operation are included in the result. select print ( a ) as a , binaryop , print ( b ) as b , print ( eadd ( a , b , binaryop )) as eadd from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 binaryop \u2502 b \u2502 eadd \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 times_int32 \u2502 0 1 2 3 \u2502 0 1 2 3 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 3 \u2502 \u2502 0\u2502 4 \u2502 0\u2502 0 12 \u2502 \u2502 1\u2502 2 1 0 \u2502 \u2502 1\u2502 3 1 \u2502 1\u2502 2 3 0 \u2502 \u2502 2\u2502 2 2 \u2502 \u2502 2\u2502 2 4 \u2502 2\u2502 2 4 4 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 0 2 \u2502 3\u2502 2 0 2 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Eadd can also be accomplished with the '+' operator: select print ( a ) as a , binaryop , print ( b ) as b , print ( a + b ) as eadd from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 binaryop \u2502 b \u2502 eadd \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 times_int32 \u2502 0 1 2 3 \u2502 0 1 2 3 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 3 \u2502 \u2502 0\u2502 4 \u2502 0\u2502 0 12 \u2502 \u2502 1\u2502 2 1 0 \u2502 \u2502 1\u2502 3 1 \u2502 1\u2502 2 3 0 \u2502 \u2502 2\u2502 2 2 \u2502 \u2502 2\u2502 2 4 \u2502 2\u2502 2 4 4 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 0 2 \u2502 3\u2502 2 0 2 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) From a graph standpoint, elementwise addition can be seen as the merging (\"union\") of two graphs, such that the result has edges from both graphs. Any edges that occur in both graphs are merged with the provided binary operator. %3 0 0 2 2 0->2 0 3 3 0->3 3 2->0 2 1 1 2->1 2 3->0 2 3->2 1 1->0 2 1->2 1 1->3 0 op %3 0 0 3 3 0->3 4 1 1 3->1 0 2 2 3->2 2 1->3 1 1->2 3 2->3 4 2->1 2 = %3 0 0 2 2 0->2 0 3 3 0->3 12 2->0 2 2->3 4 1 1 2->1 4 3->0 2 3->2 2 3->1 0 1->0 2 1->2 3 1->3 0 Elementwise Multiplication emult multiplies elements of two matrices, taking only the intersection of common elements in both matrices, if an element is missing from either the left or right side, it is ommited from the result: select print ( a ) as a , binaryop , print ( b ) as b , print ( emult ( a , b , binaryop )) as emult from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 binaryop \u2502 b \u2502 emult \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 times_int32 \u2502 0 1 2 3 \u2502 0 1 2 3 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 3 \u2502 \u2502 0\u2502 4 \u2502 0\u2502 12 \u2502 \u2502 1\u2502 2 1 0 \u2502 \u2502 1\u2502 3 1 \u2502 1\u2502 3 0 \u2502 \u2502 2\u2502 2 2 \u2502 \u2502 2\u2502 2 4 \u2502 2\u2502 4 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 0 2 \u2502 3\u2502 2 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Emult can also be accomplished with the '*' operator: select print ( a ) as a , binaryop , print ( b ) as b , print ( a * b ) as emult from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 binaryop \u2502 b \u2502 emult \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 times_int32 \u2502 0 1 2 3 \u2502 0 1 2 3 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 3 \u2502 \u2502 0\u2502 4 \u2502 0\u2502 12 \u2502 \u2502 1\u2502 2 1 0 \u2502 \u2502 1\u2502 3 1 \u2502 1\u2502 3 0 \u2502 \u2502 2\u2502 2 2 \u2502 \u2502 2\u2502 2 4 \u2502 2\u2502 4 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 0 2 \u2502 3\u2502 2 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) From a graph standpoint, elementwise multiplication can be seen as the intersection of two graphs, such that the result has edges that are only present in both graphs. The edges are combined with the provided binary operator. %3 0 0 2 2 0->2 0 3 3 0->3 3 2->0 2 1 1 2->1 2 3->0 2 3->2 1 1->0 2 1->2 1 1->3 0 op %3 0 0 3 3 0->3 4 1 1 3->1 0 2 2 3->2 2 1->3 1 1->2 3 2->3 4 2->1 2 = %3 0 0 3 3 0->3 12 2 2 3->2 2 1 1 1->3 0 1->2 3 2->1 4 Elementwise Union eunion is like eadd but differs in how the binary op is applied. A pair of scalars, alpha and beta define the inputs to the operator when entries are present in one matrix but not the other. select print ( a ) as a , binaryop , print ( b ) as b , print ( eunion ( a , 3 :: scalar , b , 4 :: scalar , binaryop )) as eunion from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 binaryop \u2502 b \u2502 eunion \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 times_int32 \u2502 0 1 2 3 \u2502 0 1 2 3 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 3 \u2502 \u2502 0\u2502 4 \u2502 0\u2502 0 12 \u2502 \u2502 1\u2502 2 1 0 \u2502 \u2502 1\u2502 3 1 \u2502 1\u2502 8 3 0 \u2502 \u2502 2\u2502 2 2 \u2502 \u2502 2\u2502 2 4 \u2502 2\u2502 8 4 12 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 0 2 \u2502 3\u2502 8 0 2 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) From a graph standpoint, elementwise union is very similar to eadd() , and can be seen as the merging (\"union\") of two graphs, such that the result has edges from both graphs. Any edges that occur in both graphs are merged with the provided binary operator. If an edge occurs in a but not in b, it is combined with the scalar alpha , if the edge occurs in the b but not in a, then the edge is combined with scalar beta . %3 0 0 2 2 0->2 0 3 3 0->3 3 2->0 2 1 1 2->1 2 3->0 2 3->2 1 1->0 2 1->2 1 1->3 0 op %3 0 0 3 3 0->3 4 1 1 3->1 0 2 2 3->2 2 1->3 1 1->2 3 2->3 4 2->1 2 = %3 0 0 2 2 0->2 0 3 3 0->3 12 2->0 8 2->3 12 1 1 2->1 4 3->0 8 3->2 2 3->1 0 1->0 8 1->2 3 1->3 0 Reduction The entire matrix can be reduced to a scalar value: select print ( a ) as a , 'plus_monoid_int32' as monoid , reduce_scalar ( a ) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 monoid \u2502 reduce_scalar \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 plus_monoid_int32 \u2502 int32:13 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 0\u2502 0 3 \u2502 \u2502 \u2502 \u2502 1\u2502 2 1 0 \u2502 \u2502 \u2502 \u2502 2\u2502 2 2 \u2502 \u2502 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) The entire matrix can be reduced to a scalar value with a provided monoid that changes the reduction operation: select print ( a ) as a , 'min_monoid_int32' as monoid , reduce_scalar ( a , 'min_monoid_int32' ) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 monoid \u2502 reduce_scalar \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 min_monoid_int32 \u2502 int32:0 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 0\u2502 0 3 \u2502 \u2502 \u2502 \u2502 1\u2502 2 1 0 \u2502 \u2502 \u2502 \u2502 2\u2502 2 2 \u2502 \u2502 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) The matrix can also be reduced to a column vector: select print ( a ) as a , 'plus_monoid_int32' as monoid , print ( reduce_vector ( a )) as reduce_vector from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 monoid \u2502 reduce_vector \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 plus_monoid_int32 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 3 \u2502 \u2502 0\u2502 3 \u2502 \u2502 1\u2502 2 1 0 \u2502 \u2502 1\u2502 3 \u2502 \u2502 2\u2502 2 2 \u2502 \u2502 2\u2502 4 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 3 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) To reduce a row vector, specify that the input should be transposed with the descriptor t0 : select print(a) as a, 'plus_monoid_int32' as monoid, print(reduce_vector(a, descriptor=> 't0' )) as transpose_reduce_vector from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 monoid \u2502 transpose_reduce_vector \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 plus_monoid_int32 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 3 \u2502 \u2502 0\u2502 6 \u2502 \u2502 1\u2502 2 1 0 \u2502 \u2502 1\u2502 2 \u2502 \u2502 2\u2502 2 2 \u2502 \u2502 2\u2502 2 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 3 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Matrix Matrix Multiplication Matrix Multiplication is the heart of linear algebra. All matrix multiplication happens over a semiring. For the most common form of matrix multiplication, the outer opperation is to multiply coresponding elements with the \"times\" operator and then reduce those products with the \"plus\" operator. This is called the plus_times semiring: select print ( a ) as a , semiring , print ( b ) as b , print ( mxm ( a , b )) as mxm from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 semiring \u2502 b \u2502 mxm \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 plus_times_int32 \u2502 0 1 2 3 \u2502 0 1 2 3 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 3 \u2502 \u2502 0\u2502 4 \u2502 0\u2502 0 6 0 \u2502 \u2502 1\u2502 2 1 0 \u2502 \u2502 1\u2502 3 1 \u2502 1\u2502 2 0 12 \u2502 \u2502 2\u2502 2 2 \u2502 \u2502 2\u2502 2 4 \u2502 2\u2502 6 10 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 0 2 \u2502 3\u2502 2 12 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) %3 0 0 2 2 0->2 0 3 3 0->3 3 2->0 2 1 1 2->1 2 3->0 2 3->2 1 1->0 2 1->2 1 1->3 0 op %3 0 0 3 3 0->3 4 1 1 3->1 0 2 2 3->2 2 1->3 1 1->2 3 2->3 4 2->1 2 = %3 0 0 1 1 0->1 0 2 2 0->2 6 3 3 0->3 0 1->1 2 1->2 0 1->3 12 2->2 6 2->3 10 3->1 2 3->3 12 AxB can also be done with the @ operator, mimicking the Python syntax. The default semiring for numeric types is plus_times . select print ( a ) as a , '@' as \"@\" , print ( b ) as b , print ( a @ b ) as mxm from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 @ \u2502 b \u2502 mxm \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 @ \u2502 0 1 2 3 \u2502 0 1 2 3 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 3 \u2502 \u2502 0\u2502 4 \u2502 0\u2502 0 6 0 \u2502 \u2502 1\u2502 2 1 0 \u2502 \u2502 1\u2502 3 1 \u2502 1\u2502 2 0 12 \u2502 \u2502 2\u2502 2 2 \u2502 \u2502 2\u2502 2 4 \u2502 2\u2502 6 10 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 0 2 \u2502 3\u2502 2 12 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Matrix Vector Multiplication Matrices can be multipled by vectors on the right taking the linear combination of the matrices columns using the vectors elements as coefficients: select print ( a ) as a , '@' as \"@\" , semiring , print ( u ) as u , print ( mxv ( a , u )) as mxv from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 @ \u2502 semiring \u2502 u \u2502 mxv \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 @ \u2502 plus_times_int32 \u2502 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 3 \u2502 \u2502 \u2502 0\u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 2 1 0 \u2502 \u2502 \u2502 1\u2502 2 \u2502 1\u2502 \u2502 \u2502 2\u2502 2 2 \u2502 \u2502 \u2502 2\u2502 \u2502 2\u2502 4 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 \u2502 3\u2502 \u2502 3\u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) From a graph standpoint, matrix vector multiplication is used to \"pull\" back to adjacent nodes from their incoming edges. When iterated, it forms the basis for working back along incoming links. %3 0 0 2 2 0->2 0 3 3 0->3 3 2->0 2 1 1 2->1 2 3->0 2 3->2 1 1->0 2 1->2 1 1->3 0 op vector cluster_vector node0 node1 1:2 node2 node3 = vector cluster_vector node0 node1 node2 2:4 node3 'mxv' is also supported by the @ operator: select print ( a ) as a , '@' as \"@\" , print ( u ) as u , print ( a @ u ) as mxv from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 @ \u2502 u \u2502 mxv \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 @ \u2502 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 3 \u2502 \u2502 0\u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 2 1 0 \u2502 \u2502 1\u2502 2 \u2502 1\u2502 \u2502 \u2502 2\u2502 2 2 \u2502 \u2502 2\u2502 \u2502 2\u2502 4 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 \u2502 3\u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Vector Matrix Multiplication Matrices can be multipled by vectors on the right taking the linear combination of the matrices rows using the vectors elements as coefficients: select print ( v ) as v , semiring , print ( b ) as b , print ( vxm ( v , b , semiring )) as vxm from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 v \u2502 semiring \u2502 b \u2502 vxm \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 plus_times_int32 \u2502 0 1 2 3 \u2502 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 \u2502 0\u2502 4 \u2502 0\u2502 \u2502 \u2502 1\u2502 \u2502 \u2502 1\u2502 3 1 \u2502 1\u2502 6 \u2502 \u2502 2\u2502 3 \u2502 \u2502 2\u2502 2 4 \u2502 2\u2502 \u2502 \u2502 3\u2502 \u2502 \u2502 3\u2502 0 2 \u2502 3\u2502 12 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) From a graph standpoint, vector matrix multiplication is used to \"push\" forward to adjacent nodes from their outgoing edges. When iterated, it forms the basis for working forward along outgoing edges. vector cluster_vector node0 node1 node2 2:3 node3 op %3 0 0 3 3 0->3 4 1 1 3->1 0 2 2 3->2 2 1->3 1 1->2 3 2->3 4 2->1 2 = vector cluster_vector node0 node1 1:6 node2 node3 3:12 'vxm' is also supported by the @ operator: select print ( v ) as v , '@' as \"@\" , print ( b ) as b , print ( v @ b ) as vxm from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 v \u2502 @ \u2502 b \u2502 vxm \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 @ \u2502 0 1 2 3 \u2502 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 \u2502 0\u2502 4 \u2502 0\u2502 \u2502 \u2502 1\u2502 \u2502 \u2502 1\u2502 3 1 \u2502 1\u2502 6 \u2502 \u2502 2\u2502 3 \u2502 \u2502 2\u2502 2 4 \u2502 2\u2502 \u2502 \u2502 3\u2502 \u2502 \u2502 3\u2502 0 2 \u2502 3\u2502 12 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Element Selection The selection method calls the GrB_select() API function. The name selection was chosen not to conflict with the SQL keyword select . Selection provides a conditional operator called an indexunaryop and a parameter for the operator to use to compare elements in the matrix. Below, all elements with values greater than 50 are returned: select print ( a ) as a , indexunaryop , print ( selection ( a , indexunaryop , 1 )) as selected from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 indexunaryop \u2502 selected \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 valuegt_int32 \u2502 0 1 2 3 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 3 \u2502 \u2502 0\u2502 3 \u2502 \u2502 1\u2502 2 1 0 \u2502 \u2502 1\u2502 2 \u2502 \u2502 2\u2502 2 2 \u2502 \u2502 2\u2502 2 2 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 2 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) %3 0 0 2 2 0->2 0 3 3 0->3 3 2->0 2 1 1 2->1 2 3->0 2 3->2 1 1->0 2 1->2 1 1->3 0 op %3 0 0 3 3 0->3 3 3->0 2 1 1 1->0 2 2 2 2->0 2 2->1 2 A useful select operator is triu , it select only upper triangular values, this turns your graph into a direct acyclic graph (DAG) by removing all the links \"back\" from higher number nodes to lower. select print(random_matrix(8, 8, 16, seed=> 0.42 , max => 42 )) as matrix , print ( selection ( random_matrix ( 8 , 8 , 16 , seed => 0.42 , max => 42 ), 'triu' , 0 )) as triu from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 matrix \u2502 triu \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 5 6 7 \u2502 0 1 2 3 4 5 6 7 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 6 31 \u2502 0\u2502 6 31 \u2502 \u2502 1\u2502 12 \u2502 1\u2502 12 \u2502 \u2502 2\u2502 26 \u2502 2\u2502 \u2502 \u2502 3\u2502 40 \u2502 3\u2502 40 \u2502 \u2502 4\u2502 11 15 7 \u2502 4\u2502 7 \u2502 \u2502 5\u2502 20 12 22 1 \u2502 5\u2502 1 \u2502 \u2502 6\u2502 1 \u2502 6\u2502 \u2502 \u2502 7\u2502 17 \u2502 7\u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select draw(random_matrix(8, 8, 16, seed=> 0.42 , max => 42 )) as uop_a_source , draw ( selection ( random_matrix ( 8 , 8 , 16 , seed => 0.42 , max => 42 ), 'triu' , 0 )) as uop_b_source %3 0 0 4 4 0->4 6 5 5 0->5 31 1 1 4->1 11 3 3 4->3 15 7 7 4->7 7 5->0 20 5->1 12 6 6 5->6 1 5->3 22 1->6 12 6->4 1 2 2 2->1 26 3->5 40 7->2 17 op %3 0 0 4 4 0->4 6 5 5 0->5 31 7 7 4->7 7 6 6 5->6 1 1 1 1->6 12 3 3 3->5 40 Kronecker The kronecker() function takes two input matrices, and replaces every element in the second matrix with a new submatrix of the first. This \"expands\" the matrix exponentially. This is useful for constructing synthetic graphs with specific power law distributions. select print ( s ) as s , semiring , print ( s ) as s , print ( kronecker ( s , s , semiring )) as kronecker from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 s \u2502 semiring \u2502 s \u2502 kronecker \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 \u2502 plus_times_int32 \u2502 0 1 \u2502 0 1 2 3 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 1 1 \u2502 \u2502 0\u2502 1 1 \u2502 0\u2502 1 1 1 1 \u2502 \u2502 1\u2502 1 \u2502 \u2502 1\u2502 1 \u2502 1\u2502 1 1 \u2502 \u2502 \u2502 \u2502 \u2502 2\u2502 1 1 \u2502 \u2502 \u2502 \u2502 \u2502 3\u2502 1 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) %3 0 0 0->0 1 1 1 0->1 1 1->1 1 op %3 0 0 0->0 1 1 1 0->1 1 1->1 1 = %3 0 0 0->0 1 1 1 0->1 1 2 2 0->2 1 3 3 0->3 1 1->1 1 1->3 1 2->2 1 2->3 1 3->3 1 Kronecker Power here's a special function for exponentiating a matrix to itself a certain number of times, kronpower .: select print ( kronpower ( s , 2 )) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 print \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \u2502 \u2502 1\u2502 1 1 1 1 1 1 1 1 \u2502 \u2502 2\u2502 1 1 1 1 1 1 1 1 \u2502 \u2502 3\u2502 1 1 1 1 \u2502 \u2502 4\u2502 1 1 1 1 1 1 1 1 \u2502 \u2502 5\u2502 1 1 1 1 \u2502 \u2502 6\u2502 1 1 1 1 \u2502 \u2502 7\u2502 1 1 \u2502 \u2502 8\u2502 1 1 1 1 1 1 1 1 \u2502 \u2502 9\u2502 1 1 1 1 \u2502 \u2502 10\u2502 1 1 1 1 \u2502 \u2502 11\u2502 1 1 \u2502 \u2502 12\u2502 1 1 1 1 \u2502 \u2502 13\u2502 1 1 \u2502 \u2502 14\u2502 1 1 \u2502 \u2502 15\u2502 1 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Kronecker products can very quickly make huge graphs with power law distributions. These are handy synthetic graphs to mimic certain statistical edge distributions common in sparse graph problems: select nvals ( kronpower ( s , 3 )) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nvals \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 6561 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Transpose A matrix can be transposed with the transpose() function: select print ( transpose ( a )) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 print \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 2 2 2 \u2502 \u2502 1\u2502 2 \u2502 \u2502 2\u2502 0 1 1 \u2502 \u2502 3\u2502 3 0 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Apply apply takes an operator of type unaryop and applies it to every element of the matrix. The 'ainv_int32' returned the additive inverse (the negative value for integers) of every element: select print ( a ) as a , unaryop , print ( apply ( a , unaryop )) as applied from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 unaryop \u2502 applied \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 ainv_int32 \u2502 0 1 2 3 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 3 \u2502 \u2502 0\u2502 0 -3 \u2502 \u2502 1\u2502 2 1 0 \u2502 \u2502 1\u2502 -2 -1 0 \u2502 \u2502 2\u2502 2 2 \u2502 \u2502 2\u2502 -2 -2 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 -2 -1 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) SuiteSparse Info The info function returns a descripton of the matrix from SuiteSparse. select info ( a ) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 info \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 \u2502 4x4 GraphBLAS int32_t matrix, bitmap by row \u2502 \u2502 A-> matrix , 9 entries , memory : 312 bytes \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 ( 1 row ) Matrix Duplication The dup function duplicates a matrix returning a new matrix object with the same values: select dup ( a ) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 dup \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32(4:4)[0:2:0 0:3:3 1:0:2 1:2:1 1:3:0 2:0:2 2:1:2 3:0:2 3:2:1] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Work Completion The wait method is used to \"complete\" a matrix, which may have pending operations waiting to be performed when using the default SuiteSparse non-blocking mode. As a side effect, wait will sort the elements of the input: select wait ( 'int32[2:2:2 3:3:3 1:1:1]' :: matrix ); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 wait \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32[1:1:1 2:2:2 3:3:3] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) The clear function clears the matrix of all elements and returns the same object, but empty. The dimensions do not change: Clearing Matrices select clear ( 'int32[1:1:1 2:2:2 3:3:3]' :: matrix ); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 clear \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Extra tests This documentation also forms the basis for the onesparse tests, These tests run the documentation against a live server, all the above results are automatically generated. select nrows ( 'int32(10)[1:1:1 2:2:2 3:3:3]' :: matrix ); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nrows \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 10 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select ncols('int32(10)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 ncols \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1152921504606846976 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nvals('int32(10)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nvals \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 3 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nrows('int32(10:)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nrows \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 10 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select ncols('int32(10:)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 ncols \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1152921504606846976 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nvals('int32(10:)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nvals \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 3 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nrows('int32(:10)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nrows \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1152921504606846976 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select ncols('int32(:10)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 ncols \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 10 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nvals('int32(:10)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nvals \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 3 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nrows('int32(10:10)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nrows \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 10 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select ncols('int32(10:10)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 ncols \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 10 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nvals('int32(10:10)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nvals \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 3 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row)","title":"Matrix Documentation"},{"location":"test_matrix_header/#matrix-documentation","text":"This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure the extension is installed. create extension if not exists onesparse ; OneSparse wraps the SuiteSparse:GraphBLAS library and extends Postgres by adding new types and functions that allow you to do sparse and dense linear algebra in Postgres. This is similar to functionality packages like numpy and scipy.sparse bring to Python. The most powerful object in OneSparse is a Matrix. A Matrix is a two dimensional array of data with a certain number of rows m and columns n . Typically matrices are very memory hungry data structures, requiring m * n memory to hold all of the elements. This limits traditional matrix libraries, because many problems in linear algebra are sparse . Not every element is used in the problem or even definable. Traditional linear algebra libraries usually encode sparse matrices into dense matrices by using the number zero to indicate \"nothing\", but this does not aleviate the memory problem. For matrices with a large number of rows and columns this means vast areas of memories filled with zeros that end up being multiplied away, wasting energy. OneSparse matrices however are smart, and can adapt to the number of actually useful elements in a Matrix. They can be dense or sparse, the SuiteSparse library will adapt to choose the right backend format.","title":"Matrix Documentation"},{"location":"test_matrix_header/#matrices-and-graphs","text":"Every matrix is a graph, whether you think of it that way or not. And every graph has a corresponding matrix. The data that you put into tables can also describe a graph, and thus a matrix. These three different ways of thinking about tables, graphs, and matrices is one of the core concepts of OneSparse: While SuiteSparse is optimized for processing sparse matrices and vectors, it also supports optimized kernels for dense objects. A dense matrix is just a sparse matrix with all its elements. In this case SuiteSparse will automatically store it in a dense optimal format and use CPUs or GPUs appropriately to process them. If the matrix has bounds, it can be printed to the console if they are reasonable size, this is useful for debugging and experimentation: select print ( 'int32(4:4)' :: matrix ); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 print \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 \u2502 \u2502 2\u2502 \u2502 \u2502 3\u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Note that this matrix is empty, it's not filled with \"zeros\", it contains no elements . The memory needed to hold the matrix contains only stored elements, if there isn't a value stored at a given row or column position, no memory is consumed. This is the \"sparse\" in sparse matrix. This is how it's possible to create an unbounded row by unbounded column matrix without exhausting memory trying to allocate 2^120 entries.","title":"Matrices and Graphs"},{"location":"test_matrix_header/#drawing-matrices-and-vectors","text":"The draw() function turns a matrix into the Graphviz DOT language that is used to draw graph diagrams: select draw ( 'int32(4:4)[1:2:1 2:3:2 3:1:3]' :: matrix ) as draw ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 draw \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 digraph { \u2502 \u2502 1 -> 2 [ label = \"1\" ] \u2502 \u2502 2 -> 3 [ label = \"2\" ] \u2502 \u2502 3 -> 1 [ label = \"3\" ] \u2502 \u2502 } \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 ( 1 row ) Will generate the following diagram: %3 1 1 2 2 1->2 1 3 3 2->3 2 3->1 3 Let's look at our cast of test objects for the remaining examples. These objects from the onesparse.test_fixture table. select * from test_fixture ; \u250c\u2500[ RECORD 1 ]\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 t \u2502 int32 \u2502 \u2502 a \u2502 int32(4:4)[0:2:0 0:3:3 1:0:2 1:2:1 1:3:0 2:0:2 2:1:2 3:0:2 3:2:1] \u2502 \u2502 b \u2502 int32(4:4)[0:3:4 1:2:3 1:3:1 2:1:2 2:3:4 3:1:0 3:2:2] \u2502 \u2502 d \u2502 int32(4:4)[0:0:1 0:1:1 0:2:1 0:3:1 1:0:1 1:1:1 1:2:1 1:3:1 2:0:1 2:1:1 2:2:1 2:3:1 3:0:1 3:1:1 3:2:1 3:3:1] \u2502 \u2502 s \u2502 int32(2:2)[0:0:1 0:1:1 1:1:1] \u2502 \u2502 u \u2502 int32(4)[1:2] \u2502 \u2502 v \u2502 int32(4)[2:3] \u2502 \u2502 unaryop \u2502 ainv_int32 \u2502 \u2502 indexunaryop \u2502 valuegt_int32 \u2502 \u2502 binaryop \u2502 times_int32 \u2502 \u2502 monoid \u2502 plus_monoid_int32 \u2502 \u2502 semiring \u2502 plus_times_int32 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Here are a couple of sparse matrices from the test_fixture table. We'll call them a and b in these docs: select print ( a ) as a , print ( b ) as b from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 b \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 0 1 2 3 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 3 \u2502 0\u2502 4 \u2502 \u2502 1\u2502 2 1 0 \u2502 1\u2502 3 1 \u2502 \u2502 2\u2502 2 2 \u2502 2\u2502 2 4 \u2502 \u2502 3\u2502 2 1 \u2502 3\u2502 0 2 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) %3 0 0 2 2 0->2 0 3 3 0->3 3 2->0 2 1 1 2->1 2 3->0 2 3->2 1 1->0 2 1->2 1 1->3 0 %3 0 0 3 3 0->3 4 1 1 3->1 0 2 2 3->2 2 1->3 1 1->2 3 2->3 4 2->1 2 Here are some sparse test vectors, they will be used for some of the examples below: select print ( u ) as u , print ( v ) as v from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 u \u2502 v \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 2 \u2502 1\u2502 \u2502 \u2502 2\u2502 \u2502 2\u2502 3 \u2502 \u2502 3\u2502 \u2502 3\u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) vector cluster_vector node0 node1 1:2 node2 node3 vector cluster_vector node0 node1 node2 2:3 node3 There is also an example \"dense\" matrix named 'd': select print ( d ) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 print \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 1 1 1 1 \u2502 \u2502 1\u2502 1 1 1 1 \u2502 \u2502 2\u2502 1 1 1 1 \u2502 \u2502 3\u2502 1 1 1 1 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) One way of thinking about a \"dense\" matrix is a fully connected graph, these can be constructed with the dense_matrix() function: %3 0 0 0->0 1 1 1 0->1 1 2 2 0->2 1 3 3 0->3 1 1->0 1 1->1 1 1->2 1 1->3 1 2->0 1 2->1 1 2->2 1 2->3 1 3->0 1 3->1 1 3->2 1 3->3 1 And another matrix named 's' which is a Sierpinsky Graph, which we'll show off a bit later. select print ( s ) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 print \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 1 1 \u2502 \u2502 1\u2502 1 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) The matrix data type wraps a SuiteSparse GrB_Matrix handle and delegates functions from SQL to the library through instances of this type.","title":"Drawing Matrices and Vectors"},{"location":"test_matrix_header/#empty-matrices","text":"An empty matrix can be constructed many ways, but one of the simplest is casting a type code to the matrix type. In this case int32 means the SuiteSparse type GrB_INT32 . select 'int32' :: matrix ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Another way to create an empty matrix is to use the matrix() constructor function: select matrix ( 'int32' ); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row)","title":"Empty Matrices"},{"location":"test_matrix_header/#matrix-dimensions","text":"The above matrices are \"unbounded\", they do not have a fixed number of rows and/or columns. The default possible number of rows and columns is defined by the SuiteSparse library to be GrB_INDEX_MAX which is 2^60 power indexes. For the purposes of this documentation this will be referred to as INDEX_MAX and matrices and vector dimensions that are INDEX_MAX in size are reffered to as \"unbounded\". For matrices with known dimensions, the dimensions can be provided in parentesis after the type code. Here a 4 row by 4 column matrix is created: select 'int32(4:4)' :: matrix ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32(4:4) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Another way to make a new matrix is with the matrix constructor function. select matrix ( 'int32' , 4 , 4 ); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32(4:4) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Either dimension can be ommited, this creates a 4 row by unbounded column matrix. select 'int32(4:)' :: matrix ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32(4:) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) This creates a unbounded row by 4 column matrix. select 'int32(:4)' :: matrix ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32(:4) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) All graphblas operations are exposed by a series of functions and operators. Here we see three very common operations, returning the number of rows, the number of columns, and the number of store values. select nrows ( 'int32' :: matrix ), ncols ( 'int32' :: matrix ), nvals ( 'int32' :: matrix ); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nrows \u2502 ncols \u2502 nvals \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1152921504606846976 \u2502 1152921504606846976 \u2502 0 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Above you can see the matrix has unbounded rows and columns (the very large number is the number of possible entries). And the number of stored values is zero. These matrices are empty, they contain no elements. Values can be specified after the type(dimension) prefix as an array of elements between square brackets. Empty brackets imply no elements, so empty square brackets are the same as no square brackets as above: select nrows ( 'int32[]' :: matrix ), ncols ( 'int32[]' :: matrix ), nvals ( 'int32[]' :: matrix ); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nrows \u2502 ncols \u2502 nvals \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1152921504606846976 \u2502 1152921504606846976 \u2502 0 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Elements are specified between square brackets are coordinates of 'row_id:column_id:value' separated by spaces: select 'int32[1:2:1 2:3:2 3:1:3]' :: matrix , 'int32(4:)[1:2:1 2:3:2 3:1:3]' :: matrix , 'int32(:4)[1:2:1 2:3:2 3:3:1]' :: matrix ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 matrix \u2502 matrix \u2502 matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32[1:2:1 2:3:2 3:1:3] \u2502 int32(4:)[1:2:1 2:3:2 3:1:3] \u2502 int32(:4)[1:2:1 2:3:2 3:3:1] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row)","title":"Matrix dimensions"},{"location":"test_matrix_header/#elements","text":"All the elements in a matrix can be iterated with the elements() function: select * from elements (( select a from test_fixture )); \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 i \u2502 j \u2502 v \u2502 \u251c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 \u2502 2 \u2502 int32:0 \u2502 \u2502 0 \u2502 3 \u2502 int32:3 \u2502 \u2502 1 \u2502 0 \u2502 int32:2 \u2502 \u2502 1 \u2502 2 \u2502 int32:1 \u2502 \u2502 1 \u2502 3 \u2502 int32:0 \u2502 \u2502 2 \u2502 0 \u2502 int32:2 \u2502 \u2502 2 \u2502 1 \u2502 int32:2 \u2502 \u2502 3 \u2502 0 \u2502 int32:2 \u2502 \u2502 3 \u2502 2 \u2502 int32:1 \u2502 \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (9 rows) The inverse operation of constructing matrices from rows can be done with matrix_agg() : select matrix_agg ( i , i , i ) as unbound_matrix from generate_series ( 0 , 10 ) as i ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 unbound_matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32[0:0:0 1:1:1 2:2:2 3:3:3 4:4:4 5:5:5 6:6:6 7:7:7 8:8:8 9:9:9 10:10:10] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Aggregate matrices are always unbounded so use resize() to bound the matrix: select print ( resize ( matrix_agg ( i , i , i ), 10 , 10 )) as bound_matrix from generate_series ( 0 , 10 ) as i ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 bound_matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 5 6 7 8 9 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 \u2502 \u2502 1\u2502 1 \u2502 \u2502 2\u2502 2 \u2502 \u2502 3\u2502 3 \u2502 \u2502 4\u2502 4 \u2502 \u2502 5\u2502 5 \u2502 \u2502 6\u2502 6 \u2502 \u2502 7\u2502 7 \u2502 \u2502 8\u2502 8 \u2502 \u2502 9\u2502 9 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Elements can be set individually with set_element , the modified input is returned: select print ( set_element ( a , 1 , 1 , 1 )) as set_element from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 set_element \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 3 \u2502 \u2502 1\u2502 2 1 1 0 \u2502 \u2502 2\u2502 2 2 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Scalar elements can be extracted individually with get_element select get_element ( a , 3 , 2 ) as get_element from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 get_element \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32:1 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) If an element does exist get_element will return an \"empty\" scalar: select get_element ( a , 3 , 3 ) as get_element from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 get_element \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row)","title":"Elements"},{"location":"test_matrix_header/#random-matrices","text":"random_matrix will generate a random matrix provided the type, number of rows, number of columns, and the number of (approximate) values, an optional max value, and an optional random seed for deterministic generation: select print(random_matrix(8, 8, 16, seed=> 0.42 , max => 42 )) as random_matrix ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 random_matrix \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 5 6 7 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 6 31 \u2502 \u2502 1\u2502 12 \u2502 \u2502 2\u2502 26 \u2502 \u2502 3\u2502 40 \u2502 \u2502 4\u2502 11 15 7 \u2502 \u2502 5\u2502 20 12 22 1 \u2502 \u2502 6\u2502 1 \u2502 \u2502 7\u2502 17 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) This random matrix is also a random graph : %3 0 0 4 4 0->4 6 5 5 0->5 31 1 1 4->1 11 3 3 4->3 15 7 7 4->7 7 5->0 20 5->1 12 6 6 5->6 1 5->3 22 1->6 12 6->4 1 2 2 2->1 26 3->5 40 7->2 17","title":"Random Matrices"},{"location":"test_matrix_header/#elementwise-addition","text":"The GraphBLAS API has elementwise operations on matrices that operate pairs of matrices. eadd computes the element-wise \u201caddition\u201d of two matrices a and b, element-wise using any binary operator. Elements present on both sides of the operation are included in the result. select print ( a ) as a , binaryop , print ( b ) as b , print ( eadd ( a , b , binaryop )) as eadd from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 binaryop \u2502 b \u2502 eadd \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 times_int32 \u2502 0 1 2 3 \u2502 0 1 2 3 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 3 \u2502 \u2502 0\u2502 4 \u2502 0\u2502 0 12 \u2502 \u2502 1\u2502 2 1 0 \u2502 \u2502 1\u2502 3 1 \u2502 1\u2502 2 3 0 \u2502 \u2502 2\u2502 2 2 \u2502 \u2502 2\u2502 2 4 \u2502 2\u2502 2 4 4 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 0 2 \u2502 3\u2502 2 0 2 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Eadd can also be accomplished with the '+' operator: select print ( a ) as a , binaryop , print ( b ) as b , print ( a + b ) as eadd from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 binaryop \u2502 b \u2502 eadd \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 times_int32 \u2502 0 1 2 3 \u2502 0 1 2 3 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 3 \u2502 \u2502 0\u2502 4 \u2502 0\u2502 0 12 \u2502 \u2502 1\u2502 2 1 0 \u2502 \u2502 1\u2502 3 1 \u2502 1\u2502 2 3 0 \u2502 \u2502 2\u2502 2 2 \u2502 \u2502 2\u2502 2 4 \u2502 2\u2502 2 4 4 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 0 2 \u2502 3\u2502 2 0 2 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) From a graph standpoint, elementwise addition can be seen as the merging (\"union\") of two graphs, such that the result has edges from both graphs. Any edges that occur in both graphs are merged with the provided binary operator. %3 0 0 2 2 0->2 0 3 3 0->3 3 2->0 2 1 1 2->1 2 3->0 2 3->2 1 1->0 2 1->2 1 1->3 0 op %3 0 0 3 3 0->3 4 1 1 3->1 0 2 2 3->2 2 1->3 1 1->2 3 2->3 4 2->1 2 = %3 0 0 2 2 0->2 0 3 3 0->3 12 2->0 2 2->3 4 1 1 2->1 4 3->0 2 3->2 2 3->1 0 1->0 2 1->2 3 1->3 0","title":"Elementwise Addition"},{"location":"test_matrix_header/#elementwise-multiplication","text":"emult multiplies elements of two matrices, taking only the intersection of common elements in both matrices, if an element is missing from either the left or right side, it is ommited from the result: select print ( a ) as a , binaryop , print ( b ) as b , print ( emult ( a , b , binaryop )) as emult from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 binaryop \u2502 b \u2502 emult \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 times_int32 \u2502 0 1 2 3 \u2502 0 1 2 3 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 3 \u2502 \u2502 0\u2502 4 \u2502 0\u2502 12 \u2502 \u2502 1\u2502 2 1 0 \u2502 \u2502 1\u2502 3 1 \u2502 1\u2502 3 0 \u2502 \u2502 2\u2502 2 2 \u2502 \u2502 2\u2502 2 4 \u2502 2\u2502 4 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 0 2 \u2502 3\u2502 2 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Emult can also be accomplished with the '*' operator: select print ( a ) as a , binaryop , print ( b ) as b , print ( a * b ) as emult from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 binaryop \u2502 b \u2502 emult \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 times_int32 \u2502 0 1 2 3 \u2502 0 1 2 3 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 3 \u2502 \u2502 0\u2502 4 \u2502 0\u2502 12 \u2502 \u2502 1\u2502 2 1 0 \u2502 \u2502 1\u2502 3 1 \u2502 1\u2502 3 0 \u2502 \u2502 2\u2502 2 2 \u2502 \u2502 2\u2502 2 4 \u2502 2\u2502 4 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 0 2 \u2502 3\u2502 2 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) From a graph standpoint, elementwise multiplication can be seen as the intersection of two graphs, such that the result has edges that are only present in both graphs. The edges are combined with the provided binary operator. %3 0 0 2 2 0->2 0 3 3 0->3 3 2->0 2 1 1 2->1 2 3->0 2 3->2 1 1->0 2 1->2 1 1->3 0 op %3 0 0 3 3 0->3 4 1 1 3->1 0 2 2 3->2 2 1->3 1 1->2 3 2->3 4 2->1 2 = %3 0 0 3 3 0->3 12 2 2 3->2 2 1 1 1->3 0 1->2 3 2->1 4","title":"Elementwise Multiplication"},{"location":"test_matrix_header/#elementwise-union","text":"eunion is like eadd but differs in how the binary op is applied. A pair of scalars, alpha and beta define the inputs to the operator when entries are present in one matrix but not the other. select print ( a ) as a , binaryop , print ( b ) as b , print ( eunion ( a , 3 :: scalar , b , 4 :: scalar , binaryop )) as eunion from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 binaryop \u2502 b \u2502 eunion \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 times_int32 \u2502 0 1 2 3 \u2502 0 1 2 3 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 3 \u2502 \u2502 0\u2502 4 \u2502 0\u2502 0 12 \u2502 \u2502 1\u2502 2 1 0 \u2502 \u2502 1\u2502 3 1 \u2502 1\u2502 8 3 0 \u2502 \u2502 2\u2502 2 2 \u2502 \u2502 2\u2502 2 4 \u2502 2\u2502 8 4 12 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 0 2 \u2502 3\u2502 8 0 2 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) From a graph standpoint, elementwise union is very similar to eadd() , and can be seen as the merging (\"union\") of two graphs, such that the result has edges from both graphs. Any edges that occur in both graphs are merged with the provided binary operator. If an edge occurs in a but not in b, it is combined with the scalar alpha , if the edge occurs in the b but not in a, then the edge is combined with scalar beta . %3 0 0 2 2 0->2 0 3 3 0->3 3 2->0 2 1 1 2->1 2 3->0 2 3->2 1 1->0 2 1->2 1 1->3 0 op %3 0 0 3 3 0->3 4 1 1 3->1 0 2 2 3->2 2 1->3 1 1->2 3 2->3 4 2->1 2 = %3 0 0 2 2 0->2 0 3 3 0->3 12 2->0 8 2->3 12 1 1 2->1 4 3->0 8 3->2 2 3->1 0 1->0 8 1->2 3 1->3 0","title":"Elementwise Union"},{"location":"test_matrix_header/#reduction","text":"The entire matrix can be reduced to a scalar value: select print ( a ) as a , 'plus_monoid_int32' as monoid , reduce_scalar ( a ) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 monoid \u2502 reduce_scalar \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 plus_monoid_int32 \u2502 int32:13 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 0\u2502 0 3 \u2502 \u2502 \u2502 \u2502 1\u2502 2 1 0 \u2502 \u2502 \u2502 \u2502 2\u2502 2 2 \u2502 \u2502 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) The entire matrix can be reduced to a scalar value with a provided monoid that changes the reduction operation: select print ( a ) as a , 'min_monoid_int32' as monoid , reduce_scalar ( a , 'min_monoid_int32' ) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 monoid \u2502 reduce_scalar \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 min_monoid_int32 \u2502 int32:0 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 0\u2502 0 3 \u2502 \u2502 \u2502 \u2502 1\u2502 2 1 0 \u2502 \u2502 \u2502 \u2502 2\u2502 2 2 \u2502 \u2502 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) The matrix can also be reduced to a column vector: select print ( a ) as a , 'plus_monoid_int32' as monoid , print ( reduce_vector ( a )) as reduce_vector from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 monoid \u2502 reduce_vector \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 plus_monoid_int32 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 3 \u2502 \u2502 0\u2502 3 \u2502 \u2502 1\u2502 2 1 0 \u2502 \u2502 1\u2502 3 \u2502 \u2502 2\u2502 2 2 \u2502 \u2502 2\u2502 4 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 3 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) To reduce a row vector, specify that the input should be transposed with the descriptor t0 : select print(a) as a, 'plus_monoid_int32' as monoid, print(reduce_vector(a, descriptor=> 't0' )) as transpose_reduce_vector from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 monoid \u2502 transpose_reduce_vector \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 plus_monoid_int32 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 3 \u2502 \u2502 0\u2502 6 \u2502 \u2502 1\u2502 2 1 0 \u2502 \u2502 1\u2502 2 \u2502 \u2502 2\u2502 2 2 \u2502 \u2502 2\u2502 2 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 3 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row)","title":"Reduction"},{"location":"test_matrix_header/#matrix-matrix-multiplication","text":"Matrix Multiplication is the heart of linear algebra. All matrix multiplication happens over a semiring. For the most common form of matrix multiplication, the outer opperation is to multiply coresponding elements with the \"times\" operator and then reduce those products with the \"plus\" operator. This is called the plus_times semiring: select print ( a ) as a , semiring , print ( b ) as b , print ( mxm ( a , b )) as mxm from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 semiring \u2502 b \u2502 mxm \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 plus_times_int32 \u2502 0 1 2 3 \u2502 0 1 2 3 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 3 \u2502 \u2502 0\u2502 4 \u2502 0\u2502 0 6 0 \u2502 \u2502 1\u2502 2 1 0 \u2502 \u2502 1\u2502 3 1 \u2502 1\u2502 2 0 12 \u2502 \u2502 2\u2502 2 2 \u2502 \u2502 2\u2502 2 4 \u2502 2\u2502 6 10 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 0 2 \u2502 3\u2502 2 12 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) %3 0 0 2 2 0->2 0 3 3 0->3 3 2->0 2 1 1 2->1 2 3->0 2 3->2 1 1->0 2 1->2 1 1->3 0 op %3 0 0 3 3 0->3 4 1 1 3->1 0 2 2 3->2 2 1->3 1 1->2 3 2->3 4 2->1 2 = %3 0 0 1 1 0->1 0 2 2 0->2 6 3 3 0->3 0 1->1 2 1->2 0 1->3 12 2->2 6 2->3 10 3->1 2 3->3 12 AxB can also be done with the @ operator, mimicking the Python syntax. The default semiring for numeric types is plus_times . select print ( a ) as a , '@' as \"@\" , print ( b ) as b , print ( a @ b ) as mxm from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 @ \u2502 b \u2502 mxm \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 @ \u2502 0 1 2 3 \u2502 0 1 2 3 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 3 \u2502 \u2502 0\u2502 4 \u2502 0\u2502 0 6 0 \u2502 \u2502 1\u2502 2 1 0 \u2502 \u2502 1\u2502 3 1 \u2502 1\u2502 2 0 12 \u2502 \u2502 2\u2502 2 2 \u2502 \u2502 2\u2502 2 4 \u2502 2\u2502 6 10 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 0 2 \u2502 3\u2502 2 12 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row)","title":"Matrix Matrix Multiplication"},{"location":"test_matrix_header/#matrix-vector-multiplication","text":"Matrices can be multipled by vectors on the right taking the linear combination of the matrices columns using the vectors elements as coefficients: select print ( a ) as a , '@' as \"@\" , semiring , print ( u ) as u , print ( mxv ( a , u )) as mxv from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 @ \u2502 semiring \u2502 u \u2502 mxv \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 @ \u2502 plus_times_int32 \u2502 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 3 \u2502 \u2502 \u2502 0\u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 2 1 0 \u2502 \u2502 \u2502 1\u2502 2 \u2502 1\u2502 \u2502 \u2502 2\u2502 2 2 \u2502 \u2502 \u2502 2\u2502 \u2502 2\u2502 4 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 \u2502 3\u2502 \u2502 3\u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) From a graph standpoint, matrix vector multiplication is used to \"pull\" back to adjacent nodes from their incoming edges. When iterated, it forms the basis for working back along incoming links. %3 0 0 2 2 0->2 0 3 3 0->3 3 2->0 2 1 1 2->1 2 3->0 2 3->2 1 1->0 2 1->2 1 1->3 0 op vector cluster_vector node0 node1 1:2 node2 node3 = vector cluster_vector node0 node1 node2 2:4 node3 'mxv' is also supported by the @ operator: select print ( a ) as a , '@' as \"@\" , print ( u ) as u , print ( a @ u ) as mxv from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 @ \u2502 u \u2502 mxv \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 @ \u2502 \u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 3 \u2502 \u2502 0\u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 2 1 0 \u2502 \u2502 1\u2502 2 \u2502 1\u2502 \u2502 \u2502 2\u2502 2 2 \u2502 \u2502 2\u2502 \u2502 2\u2502 4 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 \u2502 3\u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row)","title":"Matrix Vector Multiplication"},{"location":"test_matrix_header/#vector-matrix-multiplication","text":"Matrices can be multipled by vectors on the right taking the linear combination of the matrices rows using the vectors elements as coefficients: select print ( v ) as v , semiring , print ( b ) as b , print ( vxm ( v , b , semiring )) as vxm from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 v \u2502 semiring \u2502 b \u2502 vxm \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 plus_times_int32 \u2502 0 1 2 3 \u2502 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 \u2502 0\u2502 4 \u2502 0\u2502 \u2502 \u2502 1\u2502 \u2502 \u2502 1\u2502 3 1 \u2502 1\u2502 6 \u2502 \u2502 2\u2502 3 \u2502 \u2502 2\u2502 2 4 \u2502 2\u2502 \u2502 \u2502 3\u2502 \u2502 \u2502 3\u2502 0 2 \u2502 3\u2502 12 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) From a graph standpoint, vector matrix multiplication is used to \"push\" forward to adjacent nodes from their outgoing edges. When iterated, it forms the basis for working forward along outgoing edges. vector cluster_vector node0 node1 node2 2:3 node3 op %3 0 0 3 3 0->3 4 1 1 3->1 0 2 2 3->2 2 1->3 1 1->2 3 2->3 4 2->1 2 = vector cluster_vector node0 node1 1:6 node2 node3 3:12 'vxm' is also supported by the @ operator: select print ( v ) as v , '@' as \"@\" , print ( b ) as b , print ( v @ b ) as vxm from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 v \u2502 @ \u2502 b \u2502 vxm \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 @ \u2502 0 1 2 3 \u2502 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 \u2502 0\u2502 4 \u2502 0\u2502 \u2502 \u2502 1\u2502 \u2502 \u2502 1\u2502 3 1 \u2502 1\u2502 6 \u2502 \u2502 2\u2502 3 \u2502 \u2502 2\u2502 2 4 \u2502 2\u2502 \u2502 \u2502 3\u2502 \u2502 \u2502 3\u2502 0 2 \u2502 3\u2502 12 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row)","title":"Vector Matrix Multiplication"},{"location":"test_matrix_header/#element-selection","text":"The selection method calls the GrB_select() API function. The name selection was chosen not to conflict with the SQL keyword select . Selection provides a conditional operator called an indexunaryop and a parameter for the operator to use to compare elements in the matrix. Below, all elements with values greater than 50 are returned: select print ( a ) as a , indexunaryop , print ( selection ( a , indexunaryop , 1 )) as selected from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 indexunaryop \u2502 selected \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 valuegt_int32 \u2502 0 1 2 3 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 3 \u2502 \u2502 0\u2502 3 \u2502 \u2502 1\u2502 2 1 0 \u2502 \u2502 1\u2502 2 \u2502 \u2502 2\u2502 2 2 \u2502 \u2502 2\u2502 2 2 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 2 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) %3 0 0 2 2 0->2 0 3 3 0->3 3 2->0 2 1 1 2->1 2 3->0 2 3->2 1 1->0 2 1->2 1 1->3 0 op %3 0 0 3 3 0->3 3 3->0 2 1 1 1->0 2 2 2 2->0 2 2->1 2 A useful select operator is triu , it select only upper triangular values, this turns your graph into a direct acyclic graph (DAG) by removing all the links \"back\" from higher number nodes to lower. select print(random_matrix(8, 8, 16, seed=> 0.42 , max => 42 )) as matrix , print ( selection ( random_matrix ( 8 , 8 , 16 , seed => 0.42 , max => 42 ), 'triu' , 0 )) as triu from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 matrix \u2502 triu \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 5 6 7 \u2502 0 1 2 3 4 5 6 7 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 6 31 \u2502 0\u2502 6 31 \u2502 \u2502 1\u2502 12 \u2502 1\u2502 12 \u2502 \u2502 2\u2502 26 \u2502 2\u2502 \u2502 \u2502 3\u2502 40 \u2502 3\u2502 40 \u2502 \u2502 4\u2502 11 15 7 \u2502 4\u2502 7 \u2502 \u2502 5\u2502 20 12 22 1 \u2502 5\u2502 1 \u2502 \u2502 6\u2502 1 \u2502 6\u2502 \u2502 \u2502 7\u2502 17 \u2502 7\u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select draw(random_matrix(8, 8, 16, seed=> 0.42 , max => 42 )) as uop_a_source , draw ( selection ( random_matrix ( 8 , 8 , 16 , seed => 0.42 , max => 42 ), 'triu' , 0 )) as uop_b_source %3 0 0 4 4 0->4 6 5 5 0->5 31 1 1 4->1 11 3 3 4->3 15 7 7 4->7 7 5->0 20 5->1 12 6 6 5->6 1 5->3 22 1->6 12 6->4 1 2 2 2->1 26 3->5 40 7->2 17 op %3 0 0 4 4 0->4 6 5 5 0->5 31 7 7 4->7 7 6 6 5->6 1 1 1 1->6 12 3 3 3->5 40","title":"Element Selection"},{"location":"test_matrix_header/#kronecker","text":"The kronecker() function takes two input matrices, and replaces every element in the second matrix with a new submatrix of the first. This \"expands\" the matrix exponentially. This is useful for constructing synthetic graphs with specific power law distributions. select print ( s ) as s , semiring , print ( s ) as s , print ( kronecker ( s , s , semiring )) as kronecker from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 s \u2502 semiring \u2502 s \u2502 kronecker \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 \u2502 plus_times_int32 \u2502 0 1 \u2502 0 1 2 3 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 1 1 \u2502 \u2502 0\u2502 1 1 \u2502 0\u2502 1 1 1 1 \u2502 \u2502 1\u2502 1 \u2502 \u2502 1\u2502 1 \u2502 1\u2502 1 1 \u2502 \u2502 \u2502 \u2502 \u2502 2\u2502 1 1 \u2502 \u2502 \u2502 \u2502 \u2502 3\u2502 1 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) %3 0 0 0->0 1 1 1 0->1 1 1->1 1 op %3 0 0 0->0 1 1 1 0->1 1 1->1 1 = %3 0 0 0->0 1 1 1 0->1 1 2 2 0->2 1 3 3 0->3 1 1->1 1 1->3 1 2->2 1 2->3 1 3->3 1","title":"Kronecker"},{"location":"test_matrix_header/#kronecker-power","text":"here's a special function for exponentiating a matrix to itself a certain number of times, kronpower .: select print ( kronpower ( s , 2 )) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 print \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \u2502 \u2502 1\u2502 1 1 1 1 1 1 1 1 \u2502 \u2502 2\u2502 1 1 1 1 1 1 1 1 \u2502 \u2502 3\u2502 1 1 1 1 \u2502 \u2502 4\u2502 1 1 1 1 1 1 1 1 \u2502 \u2502 5\u2502 1 1 1 1 \u2502 \u2502 6\u2502 1 1 1 1 \u2502 \u2502 7\u2502 1 1 \u2502 \u2502 8\u2502 1 1 1 1 1 1 1 1 \u2502 \u2502 9\u2502 1 1 1 1 \u2502 \u2502 10\u2502 1 1 1 1 \u2502 \u2502 11\u2502 1 1 \u2502 \u2502 12\u2502 1 1 1 1 \u2502 \u2502 13\u2502 1 1 \u2502 \u2502 14\u2502 1 1 \u2502 \u2502 15\u2502 1 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Kronecker products can very quickly make huge graphs with power law distributions. These are handy synthetic graphs to mimic certain statistical edge distributions common in sparse graph problems: select nvals ( kronpower ( s , 3 )) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nvals \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 6561 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row)","title":"Kronecker Power"},{"location":"test_matrix_header/#transpose","text":"A matrix can be transposed with the transpose() function: select print ( transpose ( a )) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 print \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 2 2 2 \u2502 \u2502 1\u2502 2 \u2502 \u2502 2\u2502 0 1 1 \u2502 \u2502 3\u2502 3 0 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row)","title":"Transpose"},{"location":"test_matrix_header/#apply","text":"apply takes an operator of type unaryop and applies it to every element of the matrix. The 'ainv_int32' returned the additive inverse (the negative value for integers) of every element: select print ( a ) as a , unaryop , print ( apply ( a , unaryop )) as applied from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 unaryop \u2502 applied \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 1 2 3 \u2502 ainv_int32 \u2502 0 1 2 3 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 0\u2502 0 3 \u2502 \u2502 0\u2502 0 -3 \u2502 \u2502 1\u2502 2 1 0 \u2502 \u2502 1\u2502 -2 -1 0 \u2502 \u2502 2\u2502 2 2 \u2502 \u2502 2\u2502 -2 -2 \u2502 \u2502 3\u2502 2 1 \u2502 \u2502 3\u2502 -2 -1 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row)","title":"Apply"},{"location":"test_matrix_header/#suitesparse-info","text":"The info function returns a descripton of the matrix from SuiteSparse. select info ( a ) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 info \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 \u2502 4x4 GraphBLAS int32_t matrix, bitmap by row \u2502 \u2502 A-> matrix , 9 entries , memory : 312 bytes \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 ( 1 row )","title":"SuiteSparse Info"},{"location":"test_matrix_header/#matrix-duplication","text":"The dup function duplicates a matrix returning a new matrix object with the same values: select dup ( a ) from test_fixture ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 dup \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32(4:4)[0:2:0 0:3:3 1:0:2 1:2:1 1:3:0 2:0:2 2:1:2 3:0:2 3:2:1] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row)","title":"Matrix Duplication"},{"location":"test_matrix_header/#work-completion","text":"The wait method is used to \"complete\" a matrix, which may have pending operations waiting to be performed when using the default SuiteSparse non-blocking mode. As a side effect, wait will sort the elements of the input: select wait ( 'int32[2:2:2 3:3:3 1:1:1]' :: matrix ); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 wait \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32[1:1:1 2:2:2 3:3:3] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) The clear function clears the matrix of all elements and returns the same object, but empty. The dimensions do not change:","title":"Work Completion"},{"location":"test_matrix_header/#clearing-matrices","text":"select clear ( 'int32[1:1:1 2:2:2 3:3:3]' :: matrix ); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 clear \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row)","title":"Clearing Matrices"},{"location":"test_matrix_header/#extra-tests","text":"This documentation also forms the basis for the onesparse tests, These tests run the documentation against a live server, all the above results are automatically generated. select nrows ( 'int32(10)[1:1:1 2:2:2 3:3:3]' :: matrix ); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nrows \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 10 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select ncols('int32(10)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 ncols \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1152921504606846976 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nvals('int32(10)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nvals \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 3 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nrows('int32(10:)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nrows \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 10 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select ncols('int32(10:)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 ncols \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1152921504606846976 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nvals('int32(10:)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nvals \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 3 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nrows('int32(:10)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nrows \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1152921504606846976 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select ncols('int32(:10)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 ncols \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 10 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nvals('int32(:10)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nvals \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 3 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nrows('int32(10:10)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nrows \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 10 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select ncols('int32(10:10)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 ncols \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 10 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nvals('int32(10:10)[1:1:1 2:2:2 3:3:3]'::matrix); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nvals \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 3 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row)","title":"Extra tests"},{"location":"test_scalar_header/","text":"Scalar This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING' ; create extension if not exists onesparse; Describe the scalar type List of data types Schema | Name | Internal name | Size | Elements | Owner | Access privileges | Description -----------+--------+---------------+------+----------+----------+-------------------+------------- onesparse | scalar | scalar | var | | postgres | | ( 1 row ) print a scalar, this renders the value with no prefix select print ( 'int32:42' :: scalar ); print ------- 42 (1 row) Duplicate a scalar select dup ( 'int32:42' :: scalar ); dup ---------- int32:42 (1 row) Wait for a scalar to complete in non-blocking mode select wait ( 'int32:42' :: scalar ); wait ---------- int32:42 (1 row) Clear a scalar, deleting its stored element. select clear ( 'int32:42' :: scalar ); clear ------- int (1 row)","title":"Scalar"},{"location":"test_scalar_header/#scalar","text":"This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING' ; create extension if not exists onesparse; Describe the scalar type List of data types Schema | Name | Internal name | Size | Elements | Owner | Access privileges | Description -----------+--------+---------------+------+----------+----------+-------------------+------------- onesparse | scalar | scalar | var | | postgres | | ( 1 row ) print a scalar, this renders the value with no prefix select print ( 'int32:42' :: scalar ); print ------- 42 (1 row) Duplicate a scalar select dup ( 'int32:42' :: scalar ); dup ---------- int32:42 (1 row) Wait for a scalar to complete in non-blocking mode select wait ( 'int32:42' :: scalar ); wait ---------- int32:42 (1 row) Clear a scalar, deleting its stored element. select clear ( 'int32:42' :: scalar ); clear ------- int (1 row)","title":"Scalar"},{"location":"test_scalar_op_f4/","text":"Scalar float4 Operations Test various scalar math operations with native Postgres types select ( 1 :: float4 ) :: scalar + - 1 :: float4 ; ?column? --------------- fp32:0.000000 (1 row) select 1::float4 + (-1::float4)::scalar; ?column? ---------- 0 (1 row) select (1::float4)::scalar - 1::float4; ?column? --------------- fp32:0.000000 (1 row) select 1::float4 - (1::float4)::scalar; ?column? ---------- 0 (1 row) select (1::float4)::scalar * -1::float4; ?column? ---------------- fp32:-1.000000 (1 row) select 1::float4 * (-1::float4)::scalar; ?column? ---------- -1 (1 row) select (1::float4)::scalar / 1::float4; ?column? --------------- fp32:1.000000 (1 row) select 1::float4 / (1::float4)::scalar; ?column? ---------- 1 (1 row) Test construction of min, zero and max values: select '-1' :: float4 :: scalar ; scalar ---------------- fp32:-1.000000 (1 row) select '0'::float4::scalar; scalar --------------- fp32:0.000000 (1 row) select '1'::float4::scalar; scalar --------------- fp32:1.000000 (1 row) Test setting a scalar value from max to 2 select set ( '1' :: float4 :: scalar , 2 ); set --------------- fp32:2.000000 (1 row) Test various casting functions used by the CREATE CAST machinery: select scalar_float4 (( - 1 ) :: float4 ); scalar_float4 ---------------- fp32:-1.000000 (1 row) select scalar_float4((0)::float4); scalar_float4 --------------- fp32:0.000000 (1 row) select scalar_float4((1)::float4); scalar_float4 --------------- fp32:1.000000 (1 row) select float4_scalar((-1)::float4::scalar); float4_scalar --------------- -1 (1 row) select float4_scalar((0)::float4::scalar); float4_scalar --------------- 0 (1 row) select float4_scalar((1)::float4::scalar); float4_scalar --------------- 1 (1 row) These casting functions cast the Postgres type float4 to the GraphBLAS scalar type GrB_INT32 . select cast ( - 1 :: float4 as scalar ); scalar ---------------- fp32:-1.000000 (1 row) select cast(0::float4 as scalar); scalar --------------- fp32:0.000000 (1 row) select cast(1::float4 as scalar); scalar --------------- fp32:1.000000 (1 row) These tests cast back from the scalar type GrB_INT32 to the Postgres type float4 select cast (( - 1 :: float4 ) :: scalar as float4 ); float4 -------- -1 (1 row) select cast((0::float4)::scalar as float4); float4 -------- 0 (1 row) select cast((1::float4)::scalar as scalar); scalar --------------- fp32:1.000000 (1 row)","title":"Scalar float4 Operations"},{"location":"test_scalar_op_f4/#scalar-float4-operations","text":"Test various scalar math operations with native Postgres types select ( 1 :: float4 ) :: scalar + - 1 :: float4 ; ?column? --------------- fp32:0.000000 (1 row) select 1::float4 + (-1::float4)::scalar; ?column? ---------- 0 (1 row) select (1::float4)::scalar - 1::float4; ?column? --------------- fp32:0.000000 (1 row) select 1::float4 - (1::float4)::scalar; ?column? ---------- 0 (1 row) select (1::float4)::scalar * -1::float4; ?column? ---------------- fp32:-1.000000 (1 row) select 1::float4 * (-1::float4)::scalar; ?column? ---------- -1 (1 row) select (1::float4)::scalar / 1::float4; ?column? --------------- fp32:1.000000 (1 row) select 1::float4 / (1::float4)::scalar; ?column? ---------- 1 (1 row) Test construction of min, zero and max values: select '-1' :: float4 :: scalar ; scalar ---------------- fp32:-1.000000 (1 row) select '0'::float4::scalar; scalar --------------- fp32:0.000000 (1 row) select '1'::float4::scalar; scalar --------------- fp32:1.000000 (1 row) Test setting a scalar value from max to 2 select set ( '1' :: float4 :: scalar , 2 ); set --------------- fp32:2.000000 (1 row) Test various casting functions used by the CREATE CAST machinery: select scalar_float4 (( - 1 ) :: float4 ); scalar_float4 ---------------- fp32:-1.000000 (1 row) select scalar_float4((0)::float4); scalar_float4 --------------- fp32:0.000000 (1 row) select scalar_float4((1)::float4); scalar_float4 --------------- fp32:1.000000 (1 row) select float4_scalar((-1)::float4::scalar); float4_scalar --------------- -1 (1 row) select float4_scalar((0)::float4::scalar); float4_scalar --------------- 0 (1 row) select float4_scalar((1)::float4::scalar); float4_scalar --------------- 1 (1 row) These casting functions cast the Postgres type float4 to the GraphBLAS scalar type GrB_INT32 . select cast ( - 1 :: float4 as scalar ); scalar ---------------- fp32:-1.000000 (1 row) select cast(0::float4 as scalar); scalar --------------- fp32:0.000000 (1 row) select cast(1::float4 as scalar); scalar --------------- fp32:1.000000 (1 row) These tests cast back from the scalar type GrB_INT32 to the Postgres type float4 select cast (( - 1 :: float4 ) :: scalar as float4 ); float4 -------- -1 (1 row) select cast((0::float4)::scalar as float4); float4 -------- 0 (1 row) select cast((1::float4)::scalar as scalar); scalar --------------- fp32:1.000000 (1 row)","title":"Scalar float4 Operations"},{"location":"test_scalar_op_f8/","text":"Scalar float8 Operations Test various scalar math operations with native Postgres types select ( 1 :: float8 ) :: scalar + - 1 :: float8 ; ?column? --------------- fp64:0.000000 (1 row) select 1::float8 + (-1::float8)::scalar; ?column? ---------- 0 (1 row) select (1::float8)::scalar - 1::float8; ?column? --------------- fp64:0.000000 (1 row) select 1::float8 - (1::float8)::scalar; ?column? ---------- 0 (1 row) select (1::float8)::scalar * -1::float8; ?column? ---------------- fp64:-1.000000 (1 row) select 1::float8 * (-1::float8)::scalar; ?column? ---------- -1 (1 row) select (1::float8)::scalar / 1::float8; ?column? --------------- fp64:1.000000 (1 row) select 1::float8 / (1::float8)::scalar; ?column? ---------- 1 (1 row) Test construction of min, zero and max values: select '-1' :: float8 :: scalar ; scalar ---------------- fp64:-1.000000 (1 row) select '0'::float8::scalar; scalar --------------- fp64:0.000000 (1 row) select '1'::float8::scalar; scalar --------------- fp64:1.000000 (1 row) Test setting a scalar value from max to 2 select set ( '1' :: float8 :: scalar , 2 ); set --------------- fp64:2.000000 (1 row) Test various casting functions used by the CREATE CAST machinery: select scalar_float8 (( - 1 ) :: float8 ); scalar_float8 ---------------- fp64:-1.000000 (1 row) select scalar_float8((0)::float8); scalar_float8 --------------- fp64:0.000000 (1 row) select scalar_float8((1)::float8); scalar_float8 --------------- fp64:1.000000 (1 row) select float8_scalar((-1)::float8::scalar); float8_scalar --------------- -1 (1 row) select float8_scalar((0)::float8::scalar); float8_scalar --------------- 0 (1 row) select float8_scalar((1)::float8::scalar); float8_scalar --------------- 1 (1 row) These casting functions cast the Postgres type float8 to the GraphBLAS scalar type GrB_INT64 . select cast ( - 1 :: float8 as scalar ); scalar ---------------- fp64:-1.000000 (1 row) select cast(0::float8 as scalar); scalar --------------- fp64:0.000000 (1 row) select cast(1::float8 as scalar); scalar --------------- fp64:1.000000 (1 row) These tests cast back from the scalar type GrB_INT64 to the Postgres type float8 select cast (( - 1 :: float8 ) :: scalar as float8 ); float8 -------- -1 (1 row) select cast((0::float8)::scalar as float8); float8 -------- 0 (1 row) select cast((1::float8)::scalar as scalar); scalar --------------- fp64:1.000000 (1 row)","title":"Scalar float8 Operations"},{"location":"test_scalar_op_f8/#scalar-float8-operations","text":"Test various scalar math operations with native Postgres types select ( 1 :: float8 ) :: scalar + - 1 :: float8 ; ?column? --------------- fp64:0.000000 (1 row) select 1::float8 + (-1::float8)::scalar; ?column? ---------- 0 (1 row) select (1::float8)::scalar - 1::float8; ?column? --------------- fp64:0.000000 (1 row) select 1::float8 - (1::float8)::scalar; ?column? ---------- 0 (1 row) select (1::float8)::scalar * -1::float8; ?column? ---------------- fp64:-1.000000 (1 row) select 1::float8 * (-1::float8)::scalar; ?column? ---------- -1 (1 row) select (1::float8)::scalar / 1::float8; ?column? --------------- fp64:1.000000 (1 row) select 1::float8 / (1::float8)::scalar; ?column? ---------- 1 (1 row) Test construction of min, zero and max values: select '-1' :: float8 :: scalar ; scalar ---------------- fp64:-1.000000 (1 row) select '0'::float8::scalar; scalar --------------- fp64:0.000000 (1 row) select '1'::float8::scalar; scalar --------------- fp64:1.000000 (1 row) Test setting a scalar value from max to 2 select set ( '1' :: float8 :: scalar , 2 ); set --------------- fp64:2.000000 (1 row) Test various casting functions used by the CREATE CAST machinery: select scalar_float8 (( - 1 ) :: float8 ); scalar_float8 ---------------- fp64:-1.000000 (1 row) select scalar_float8((0)::float8); scalar_float8 --------------- fp64:0.000000 (1 row) select scalar_float8((1)::float8); scalar_float8 --------------- fp64:1.000000 (1 row) select float8_scalar((-1)::float8::scalar); float8_scalar --------------- -1 (1 row) select float8_scalar((0)::float8::scalar); float8_scalar --------------- 0 (1 row) select float8_scalar((1)::float8::scalar); float8_scalar --------------- 1 (1 row) These casting functions cast the Postgres type float8 to the GraphBLAS scalar type GrB_INT64 . select cast ( - 1 :: float8 as scalar ); scalar ---------------- fp64:-1.000000 (1 row) select cast(0::float8 as scalar); scalar --------------- fp64:0.000000 (1 row) select cast(1::float8 as scalar); scalar --------------- fp64:1.000000 (1 row) These tests cast back from the scalar type GrB_INT64 to the Postgres type float8 select cast (( - 1 :: float8 ) :: scalar as float8 ); float8 -------- -1 (1 row) select cast((0::float8)::scalar as float8); float8 -------- 0 (1 row) select cast((1::float8)::scalar as scalar); scalar --------------- fp64:1.000000 (1 row)","title":"Scalar float8 Operations"},{"location":"test_scalar_op_i2/","text":"Scalar smallint Operations Test various scalar math operations with native Postgres types select ( 1 :: smallint ) :: scalar + - 1 :: smallint ; ?column? ---------- int16:0 (1 row) select 1::smallint + (-1::smallint)::scalar; ?column? ---------- 0 (1 row) select (1::smallint)::scalar - 1::smallint; ?column? ---------- int16:0 (1 row) select 1::smallint - (1::smallint)::scalar; ?column? ---------- 0 (1 row) select (1::smallint)::scalar * -1::smallint; ?column? ---------- int16:-1 (1 row) select 1::smallint * (-1::smallint)::scalar; ?column? ---------- -1 (1 row) select (1::smallint)::scalar / 1::smallint; ?column? ---------- int16:1 (1 row) select 1::smallint / (1::smallint)::scalar; ?column? ---------- 1 (1 row) Test construction of min, zero and max values: select '-1' :: smallint :: scalar ; scalar ---------- int16:-1 (1 row) select '0'::smallint::scalar; scalar --------- int16:0 (1 row) select '1'::smallint::scalar; scalar --------- int16:1 (1 row) Test setting a scalar value from max to 2 select set ( '1' :: smallint :: scalar , 2 ); set --------- int16:2 (1 row) Test various casting functions used by the CREATE CAST machinery: select scalar_smallint (( - 1 ) :: smallint ); scalar_smallint ----------------- int16:-1 (1 row) select scalar_smallint((0)::smallint); scalar_smallint ----------------- int16:0 (1 row) select scalar_smallint((1)::smallint); scalar_smallint ----------------- int16:1 (1 row) select smallint_scalar((-1)::smallint::scalar); smallint_scalar ----------------- -1 (1 row) select smallint_scalar((0)::smallint::scalar); smallint_scalar ----------------- 0 (1 row) select smallint_scalar((1)::smallint::scalar); smallint_scalar ----------------- 1 (1 row) These casting functions cast the Postgres type smallint to the GraphBLAS scalar type GrB_INT16 . select cast ( - 1 :: smallint as scalar ); scalar ---------- int16:-1 (1 row) select cast(0::smallint as scalar); scalar --------- int16:0 (1 row) select cast(1::smallint as scalar); scalar --------- int16:1 (1 row) These tests cast back from the scalar type GrB_INT16 to the Postgres type smallint select cast (( - 1 :: smallint ) :: scalar as smallint ); int2 ------ -1 (1 row) select cast((0::smallint)::scalar as smallint); int2 ------ 0 (1 row) select cast((1::smallint)::scalar as scalar); scalar --------- int16:1 (1 row)","title":"Scalar smallint Operations"},{"location":"test_scalar_op_i2/#scalar-smallint-operations","text":"Test various scalar math operations with native Postgres types select ( 1 :: smallint ) :: scalar + - 1 :: smallint ; ?column? ---------- int16:0 (1 row) select 1::smallint + (-1::smallint)::scalar; ?column? ---------- 0 (1 row) select (1::smallint)::scalar - 1::smallint; ?column? ---------- int16:0 (1 row) select 1::smallint - (1::smallint)::scalar; ?column? ---------- 0 (1 row) select (1::smallint)::scalar * -1::smallint; ?column? ---------- int16:-1 (1 row) select 1::smallint * (-1::smallint)::scalar; ?column? ---------- -1 (1 row) select (1::smallint)::scalar / 1::smallint; ?column? ---------- int16:1 (1 row) select 1::smallint / (1::smallint)::scalar; ?column? ---------- 1 (1 row) Test construction of min, zero and max values: select '-1' :: smallint :: scalar ; scalar ---------- int16:-1 (1 row) select '0'::smallint::scalar; scalar --------- int16:0 (1 row) select '1'::smallint::scalar; scalar --------- int16:1 (1 row) Test setting a scalar value from max to 2 select set ( '1' :: smallint :: scalar , 2 ); set --------- int16:2 (1 row) Test various casting functions used by the CREATE CAST machinery: select scalar_smallint (( - 1 ) :: smallint ); scalar_smallint ----------------- int16:-1 (1 row) select scalar_smallint((0)::smallint); scalar_smallint ----------------- int16:0 (1 row) select scalar_smallint((1)::smallint); scalar_smallint ----------------- int16:1 (1 row) select smallint_scalar((-1)::smallint::scalar); smallint_scalar ----------------- -1 (1 row) select smallint_scalar((0)::smallint::scalar); smallint_scalar ----------------- 0 (1 row) select smallint_scalar((1)::smallint::scalar); smallint_scalar ----------------- 1 (1 row) These casting functions cast the Postgres type smallint to the GraphBLAS scalar type GrB_INT16 . select cast ( - 1 :: smallint as scalar ); scalar ---------- int16:-1 (1 row) select cast(0::smallint as scalar); scalar --------- int16:0 (1 row) select cast(1::smallint as scalar); scalar --------- int16:1 (1 row) These tests cast back from the scalar type GrB_INT16 to the Postgres type smallint select cast (( - 1 :: smallint ) :: scalar as smallint ); int2 ------ -1 (1 row) select cast((0::smallint)::scalar as smallint); int2 ------ 0 (1 row) select cast((1::smallint)::scalar as scalar); scalar --------- int16:1 (1 row)","title":"Scalar smallint Operations"},{"location":"test_scalar_op_i4/","text":"Scalar integer Operations Test various scalar math operations with native Postgres types select ( 1 :: integer ) :: scalar + - 1 :: integer ; ?column? ---------- int32:0 (1 row) select 1::integer + (-1::integer)::scalar; ?column? ---------- 0 (1 row) select (1::integer)::scalar - 1::integer; ?column? ---------- int32:0 (1 row) select 1::integer - (1::integer)::scalar; ?column? ---------- 0 (1 row) select (1::integer)::scalar * -1::integer; ?column? ---------- int32:-1 (1 row) select 1::integer * (-1::integer)::scalar; ?column? ---------- -1 (1 row) select (1::integer)::scalar / 1::integer; ?column? ---------- int32:1 (1 row) select 1::integer / (1::integer)::scalar; ?column? ---------- 1 (1 row) Test construction of min, zero and max values: select '-1' :: integer :: scalar ; scalar ---------- int32:-1 (1 row) select '0'::integer::scalar; scalar --------- int32:0 (1 row) select '1'::integer::scalar; scalar --------- int32:1 (1 row) Test setting a scalar value from max to 2 select set ( '1' :: integer :: scalar , 2 ); set --------- int32:2 (1 row) Test various casting functions used by the CREATE CAST machinery: select scalar_integer (( - 1 ) :: integer ); scalar_integer ---------------- int32:-1 (1 row) select scalar_integer((0)::integer); scalar_integer ---------------- int32:0 (1 row) select scalar_integer((1)::integer); scalar_integer ---------------- int32:1 (1 row) select integer_scalar((-1)::integer::scalar); integer_scalar ---------------- -1 (1 row) select integer_scalar((0)::integer::scalar); integer_scalar ---------------- 0 (1 row) select integer_scalar((1)::integer::scalar); integer_scalar ---------------- 1 (1 row) These casting functions cast the Postgres type integer to the GraphBLAS scalar type GrB_INT32 . select cast ( - 1 :: integer as scalar ); scalar ---------- int32:-1 (1 row) select cast(0::integer as scalar); scalar --------- int32:0 (1 row) select cast(1::integer as scalar); scalar --------- int32:1 (1 row) These tests cast back from the scalar type GrB_INT32 to the Postgres type integer select cast (( - 1 :: integer ) :: scalar as integer ); int4 ------ -1 (1 row) select cast((0::integer)::scalar as integer); int4 ------ 0 (1 row) select cast((1::integer)::scalar as scalar); scalar --------- int32:1 (1 row)","title":"Scalar integer Operations"},{"location":"test_scalar_op_i4/#scalar-integer-operations","text":"Test various scalar math operations with native Postgres types select ( 1 :: integer ) :: scalar + - 1 :: integer ; ?column? ---------- int32:0 (1 row) select 1::integer + (-1::integer)::scalar; ?column? ---------- 0 (1 row) select (1::integer)::scalar - 1::integer; ?column? ---------- int32:0 (1 row) select 1::integer - (1::integer)::scalar; ?column? ---------- 0 (1 row) select (1::integer)::scalar * -1::integer; ?column? ---------- int32:-1 (1 row) select 1::integer * (-1::integer)::scalar; ?column? ---------- -1 (1 row) select (1::integer)::scalar / 1::integer; ?column? ---------- int32:1 (1 row) select 1::integer / (1::integer)::scalar; ?column? ---------- 1 (1 row) Test construction of min, zero and max values: select '-1' :: integer :: scalar ; scalar ---------- int32:-1 (1 row) select '0'::integer::scalar; scalar --------- int32:0 (1 row) select '1'::integer::scalar; scalar --------- int32:1 (1 row) Test setting a scalar value from max to 2 select set ( '1' :: integer :: scalar , 2 ); set --------- int32:2 (1 row) Test various casting functions used by the CREATE CAST machinery: select scalar_integer (( - 1 ) :: integer ); scalar_integer ---------------- int32:-1 (1 row) select scalar_integer((0)::integer); scalar_integer ---------------- int32:0 (1 row) select scalar_integer((1)::integer); scalar_integer ---------------- int32:1 (1 row) select integer_scalar((-1)::integer::scalar); integer_scalar ---------------- -1 (1 row) select integer_scalar((0)::integer::scalar); integer_scalar ---------------- 0 (1 row) select integer_scalar((1)::integer::scalar); integer_scalar ---------------- 1 (1 row) These casting functions cast the Postgres type integer to the GraphBLAS scalar type GrB_INT32 . select cast ( - 1 :: integer as scalar ); scalar ---------- int32:-1 (1 row) select cast(0::integer as scalar); scalar --------- int32:0 (1 row) select cast(1::integer as scalar); scalar --------- int32:1 (1 row) These tests cast back from the scalar type GrB_INT32 to the Postgres type integer select cast (( - 1 :: integer ) :: scalar as integer ); int4 ------ -1 (1 row) select cast((0::integer)::scalar as integer); int4 ------ 0 (1 row) select cast((1::integer)::scalar as scalar); scalar --------- int32:1 (1 row)","title":"Scalar integer Operations"},{"location":"test_scalar_op_i8/","text":"Scalar bigint Operations Test various scalar math operations with native Postgres types select ( 1 :: bigint ) :: scalar + - 1 :: bigint ; ?column? ---------- int64:0 (1 row) select 1::bigint + (-1::bigint)::scalar; ?column? ---------- 0 (1 row) select (1::bigint)::scalar - 1::bigint; ?column? ---------- int64:0 (1 row) select 1::bigint - (1::bigint)::scalar; ?column? ---------- 0 (1 row) select (1::bigint)::scalar * -1::bigint; ?column? ---------- int64:-1 (1 row) select 1::bigint * (-1::bigint)::scalar; ?column? ---------- -1 (1 row) select (1::bigint)::scalar / 1::bigint; ?column? ---------- int64:1 (1 row) select 1::bigint / (1::bigint)::scalar; ?column? ---------- 1 (1 row) Test construction of min, zero and max values: select '-1' :: bigint :: scalar ; scalar ---------- int64:-1 (1 row) select '0'::bigint::scalar; scalar --------- int64:0 (1 row) select '1'::bigint::scalar; scalar --------- int64:1 (1 row) Test setting a scalar value from max to 2 select set ( '1' :: bigint :: scalar , 2 ); set --------- int64:2 (1 row) Test various casting functions used by the CREATE CAST machinery: select scalar_bigint (( - 1 ) :: bigint ); scalar_bigint --------------- int64:-1 (1 row) select scalar_bigint((0)::bigint); scalar_bigint --------------- int64:0 (1 row) select scalar_bigint((1)::bigint); scalar_bigint --------------- int64:1 (1 row) select bigint_scalar((-1)::bigint::scalar); bigint_scalar --------------- -1 (1 row) select bigint_scalar((0)::bigint::scalar); bigint_scalar --------------- 0 (1 row) select bigint_scalar((1)::bigint::scalar); bigint_scalar --------------- 1 (1 row) These casting functions cast the Postgres type bigint to the GraphBLAS scalar type GrB_INT64 . select cast ( - 1 :: bigint as scalar ); scalar ---------- int64:-1 (1 row) select cast(0::bigint as scalar); scalar --------- int64:0 (1 row) select cast(1::bigint as scalar); scalar --------- int64:1 (1 row) These tests cast back from the scalar type GrB_INT64 to the Postgres type bigint select cast (( - 1 :: bigint ) :: scalar as bigint ); int8 ------ -1 (1 row) select cast((0::bigint)::scalar as bigint); int8 ------ 0 (1 row) select cast((1::bigint)::scalar as scalar); scalar --------- int64:1 (1 row)","title":"Scalar bigint Operations"},{"location":"test_scalar_op_i8/#scalar-bigint-operations","text":"Test various scalar math operations with native Postgres types select ( 1 :: bigint ) :: scalar + - 1 :: bigint ; ?column? ---------- int64:0 (1 row) select 1::bigint + (-1::bigint)::scalar; ?column? ---------- 0 (1 row) select (1::bigint)::scalar - 1::bigint; ?column? ---------- int64:0 (1 row) select 1::bigint - (1::bigint)::scalar; ?column? ---------- 0 (1 row) select (1::bigint)::scalar * -1::bigint; ?column? ---------- int64:-1 (1 row) select 1::bigint * (-1::bigint)::scalar; ?column? ---------- -1 (1 row) select (1::bigint)::scalar / 1::bigint; ?column? ---------- int64:1 (1 row) select 1::bigint / (1::bigint)::scalar; ?column? ---------- 1 (1 row) Test construction of min, zero and max values: select '-1' :: bigint :: scalar ; scalar ---------- int64:-1 (1 row) select '0'::bigint::scalar; scalar --------- int64:0 (1 row) select '1'::bigint::scalar; scalar --------- int64:1 (1 row) Test setting a scalar value from max to 2 select set ( '1' :: bigint :: scalar , 2 ); set --------- int64:2 (1 row) Test various casting functions used by the CREATE CAST machinery: select scalar_bigint (( - 1 ) :: bigint ); scalar_bigint --------------- int64:-1 (1 row) select scalar_bigint((0)::bigint); scalar_bigint --------------- int64:0 (1 row) select scalar_bigint((1)::bigint); scalar_bigint --------------- int64:1 (1 row) select bigint_scalar((-1)::bigint::scalar); bigint_scalar --------------- -1 (1 row) select bigint_scalar((0)::bigint::scalar); bigint_scalar --------------- 0 (1 row) select bigint_scalar((1)::bigint::scalar); bigint_scalar --------------- 1 (1 row) These casting functions cast the Postgres type bigint to the GraphBLAS scalar type GrB_INT64 . select cast ( - 1 :: bigint as scalar ); scalar ---------- int64:-1 (1 row) select cast(0::bigint as scalar); scalar --------- int64:0 (1 row) select cast(1::bigint as scalar); scalar --------- int64:1 (1 row) These tests cast back from the scalar type GrB_INT64 to the Postgres type bigint select cast (( - 1 :: bigint ) :: scalar as bigint ); int8 ------ -1 (1 row) select cast((0::bigint)::scalar as bigint); int8 ------ 0 (1 row) select cast((1::bigint)::scalar as scalar); scalar --------- int64:1 (1 row)","title":"Scalar bigint Operations"},{"location":"test_vector_header/","text":"Vectors This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING' ; create extension if not exists onesparse; An empty vector can be constructed many ways, but one of the simplest is casting a type code to the matrix type. In this case int32 means GrB_INT32. The type codes are intentionally compressed to be as short as possible for smaller pg_dumps. Much of these functions are basically vector versions of the same functions for matrix. See those docs for details: select 'int32' :: vector ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 vector \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nvals('int32'::vector); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nvals \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select size('int32'::vector); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 size \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1152921504606846976 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select 'int32[]'::vector; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 vector \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nvals('int32[]'::vector); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nvals \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select size('int32[]'::vector); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 size \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1152921504606846976 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select 'int32(10)'::vector; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 vector \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32(10) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nvals('int32(10)'::vector); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nvals \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select size('int32(10)'::vector); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 size \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 10 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select 'int32(10)[]'::vector; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 vector \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32(10) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nvals('int32(10)[]'::vector); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nvals \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select size('int32(10)[]'::vector); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 size \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 10 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select 'int32[0:1 1:2 2:3]'::vector; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 vector \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32[0:1 1:2 2:3] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nvals('int32[0:1 1:2 2:3]'::vector); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nvals \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 3 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select * from elements('int32[0:1 1:2 2:3]'::vector); \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 i \u2502 v \u2502 \u251c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 \u2502 int32:1 \u2502 \u2502 1 \u2502 int32:2 \u2502 \u2502 2 \u2502 int32:3 \u2502 \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (3 rows) select 'int32(10)[0:1 1:2 2:3]'::vector; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 vector \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32(10)[0:1 1:2 2:3] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select size('int32(10)[0:1 1:2 2:3]'::vector); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 size \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 10 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select size('int32(2)[0:1 1:2 2:3]'::vector); ERROR: INVALID_INDEX GraphBLAS error: GrB_INVALID_INDEX function: GrB_Vector_setElement_INT64 (w, x, row) Row index 2 out of range; must be < 2: Error setting Vector Element LINE 1: select size('int32(2)[0:1 1:2 2:3]'::vector); ^ select eadd('int32[0:1 1:2 2:3]'::vector, 'int32[0:1 1:2 2:3]'::vector, 'plus_int32'); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 eadd \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32[0:2 1:4 2:6] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select emult('int32[0:1 1:2 2:3]'::vector, 'int32[0:1 1:2 2:3]'::vector, 'times_int32'); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 emult \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32[0:1 1:4 2:9] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select eunion('int32[0:1 1:2 2:3]'::vector, 42, 'int32[0:1 1:2 2:3]'::vector, 84, 'plus_int32'); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 eunion \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32[0:2 1:4 2:6] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select reduce_scalar('int32[0:1 1:2 2:3]'::vector, 'plus_monoid_int32'); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 reduce_scalar \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32:6 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select selection('int32[0:1 1:2 2:3]'::vector, 'valuegt_int32', 1); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 selection \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32[1:2 2:3] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select apply('int32[1:1 2:2 3:3]'::vector, 'ainv_int32'::unaryop); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 apply \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32[1:-1 2:-2 3:-3] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Elements can be set individually with set_element , the modified input is returned: select set_element ( 'int32[1:1 2:2 3:3]' :: vector , 4 , 4 ); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 set_element \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32[1:1 2:2 3:3 4:4] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Scalar elements can be extracted individually with get_element select get_element ( 'int32[1:1 2:2 3:3]' :: vector , 3 ); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 get_element \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32:3 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select print('int32(4)[1:1 2:2 3:3]'::vector); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 print \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 1 \u2502 \u2502 2\u2502 2 \u2502 \u2502 3\u2502 3 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select wait('int32[0:1 1:2 2:3]'::vector); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 wait \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select dup('int32[0:1 1:2 2:3]'::vector); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 dup \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32[0:1 1:2 2:3] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select clear('int32[0:1 1:2 2:3]'::vector); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 clear \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row)","title":"Vectors"},{"location":"test_vector_header/#vectors","text":"This documentation is also tests for the code, the examples below show the literal output of these statements from Postgres. Some setup to make sure warnings are shown, and that the extension is installed. set client_min_messages = 'WARNING' ; create extension if not exists onesparse; An empty vector can be constructed many ways, but one of the simplest is casting a type code to the matrix type. In this case int32 means GrB_INT32. The type codes are intentionally compressed to be as short as possible for smaller pg_dumps. Much of these functions are basically vector versions of the same functions for matrix. See those docs for details: select 'int32' :: vector ; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 vector \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nvals('int32'::vector); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nvals \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select size('int32'::vector); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 size \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1152921504606846976 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select 'int32[]'::vector; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 vector \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nvals('int32[]'::vector); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nvals \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select size('int32[]'::vector); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 size \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1152921504606846976 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select 'int32(10)'::vector; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 vector \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32(10) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nvals('int32(10)'::vector); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nvals \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select size('int32(10)'::vector); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 size \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 10 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select 'int32(10)[]'::vector; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 vector \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32(10) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nvals('int32(10)[]'::vector); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nvals \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select size('int32(10)[]'::vector); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 size \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 10 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select 'int32[0:1 1:2 2:3]'::vector; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 vector \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32[0:1 1:2 2:3] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select nvals('int32[0:1 1:2 2:3]'::vector); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 nvals \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 3 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select * from elements('int32[0:1 1:2 2:3]'::vector); \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 i \u2502 v \u2502 \u251c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 \u2502 int32:1 \u2502 \u2502 1 \u2502 int32:2 \u2502 \u2502 2 \u2502 int32:3 \u2502 \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (3 rows) select 'int32(10)[0:1 1:2 2:3]'::vector; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 vector \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32(10)[0:1 1:2 2:3] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select size('int32(10)[0:1 1:2 2:3]'::vector); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 size \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 10 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select size('int32(2)[0:1 1:2 2:3]'::vector); ERROR: INVALID_INDEX GraphBLAS error: GrB_INVALID_INDEX function: GrB_Vector_setElement_INT64 (w, x, row) Row index 2 out of range; must be < 2: Error setting Vector Element LINE 1: select size('int32(2)[0:1 1:2 2:3]'::vector); ^ select eadd('int32[0:1 1:2 2:3]'::vector, 'int32[0:1 1:2 2:3]'::vector, 'plus_int32'); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 eadd \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32[0:2 1:4 2:6] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select emult('int32[0:1 1:2 2:3]'::vector, 'int32[0:1 1:2 2:3]'::vector, 'times_int32'); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 emult \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32[0:1 1:4 2:9] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select eunion('int32[0:1 1:2 2:3]'::vector, 42, 'int32[0:1 1:2 2:3]'::vector, 84, 'plus_int32'); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 eunion \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32[0:2 1:4 2:6] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select reduce_scalar('int32[0:1 1:2 2:3]'::vector, 'plus_monoid_int32'); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 reduce_scalar \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32:6 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select selection('int32[0:1 1:2 2:3]'::vector, 'valuegt_int32', 1); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 selection \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32[1:2 2:3] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select apply('int32[1:1 2:2 3:3]'::vector, 'ainv_int32'::unaryop); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 apply \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32[1:-1 2:-2 3:-3] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Elements can be set individually with set_element , the modified input is returned: select set_element ( 'int32[1:1 2:2 3:3]' :: vector , 4 , 4 ); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 set_element \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32[1:1 2:2 3:3 4:4] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) Scalar elements can be extracted individually with get_element select get_element ( 'int32[1:1 2:2 3:3]' :: vector , 3 ); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 get_element \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32:3 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select print('int32(4)[1:1 2:2 3:3]'::vector); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 print \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 \u2502 \u2500\u2500\u2500 \u2502 \u2502 0\u2502 \u2502 \u2502 1\u2502 1 \u2502 \u2502 2\u2502 2 \u2502 \u2502 3\u2502 3 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select wait('int32[0:1 1:2 2:3]'::vector); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 wait \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select dup('int32[0:1 1:2 2:3]'::vector); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 dup \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 int32[0:1 1:2 2:3] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row) select clear('int32[0:1 1:2 2:3]'::vector); \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 clear \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 (1 row)","title":"Vectors"}]}